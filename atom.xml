<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>weiqinl</title>
  
  <subtitle>web engineer</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://weiqinl.com/"/>
  <updated>2018-05-17T02:23:24.000Z</updated>
  <id>http://weiqinl.com/</id>
  
  <author>
    <name>weiqinl</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>javascript中!=、!==、==、===操作符总结</title>
    <link href="http://weiqinl.com/2018/05/17/javascript%E4%B8%AD%E4%B8%8D%E7%AD%89%E3%80%81%E4%B8%8D%E5%85%A8%E7%AD%89%E3%80%81%E7%9B%B8%E7%AD%89%E3%80%81%E5%85%A8%E7%AD%89%E6%93%8D%E4%BD%9C%E7%AC%A6%E6%80%BB%E7%BB%93/"/>
    <id>http://weiqinl.com/2018/05/17/javascript中不等、不全等、相等、全等操作符总结/</id>
    <published>2018-05-17T02:04:10.000Z</published>
    <updated>2018-05-17T02:23:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript 有两种比较方式：严格比较运算符和转换类型比较运算符。<br>在相等运算符中对应 <code>===</code> 、<code>!==</code>和 <code>==</code>、<code>!=</code>。</p><h2 id="先举个栗子"><a href="#先举个栗子" class="headerlink" title="先举个栗子"></a>先举个栗子</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'1'</span></span><br><span class="line"><span class="keyword">var</span> num0 = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> num1 = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> blT = <span class="literal">true</span></span><br><span class="line"><span class="keyword">var</span> blF = <span class="literal">false</span></span><br><span class="line"><span class="keyword">var</span> nul = <span class="literal">null</span></span><br><span class="line"><span class="keyword">var</span> und = <span class="literal">undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(str == num1) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(str == blT) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(blT == num1) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(blF == num0) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(nul == und) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str === num1) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(str === blT) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(blT === num1) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(blF === num0) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(nul === und) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>相等操作符(<code>==</code>)会为两个不同类型的操作数进行类型转换，然后进行严格比较。<br>严格相等操作符(<code>===</code>),一般也叫做全等操作符。会先判断类型，再比较值是否相等。<br><a id="more"></a></p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>类型转换的途径:<br>类型(x) | 类型(y)  | 结果<br>:—: | :—: | :—:<br>undefined | null | true<br>字符串 | 数字 | toNumber(x) == y<br>布尔值 | 数字 | toNumber(x) == y<br>对象 | 字符串/数字 | toPrimary(x) == y</p><p>对于两个类型不同的操作数比较。</p><ul><li>字符串、布尔值都会先转换成数字类型，再做比较。<code>toNumber(x)</code></li><li>对于复杂数据类型，会先将其<a href="http://www.cnblogs.com/weiqinl/p/8380060.html" target="_blank" rel="noopener">转换为原始值</a>，之后，再根据上一个规则比较。<br><code>x = toPrimary(obj) ==&gt; toNumber(x)</code><br>而，如何转成原始类型值呢，一般都会自动通过<a href="http://weiqinl.com/2018/03/31/JavaScript%E5%AF%B9%E8%B1%A1%E7%9A%84valueOf-%E6%96%B9%E6%B3%95/">自带的<code>valueOf()</code>方法</a>或者<code>toString()</code>方法实现。如果转换之后非原始值，比较操作会报类型错误。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">具体过程：</span><br><span class="line">先执行`valueOf`方法，如果该方法返回一个原始值，则将这个原始值转换为数字，并返回这个数字，转换过程结束。如果返回非原始值，继续下一步。</span><br><span class="line">否则，执行`toString`方法，如果该方法返回一个原始值，则将这个原始值转换为数字，并返回这个数字，转换过程结束。如果返回非原始值 ，继续下一步。</span><br><span class="line">以上都没有成功转换为原始值，则抛出一个类型转换错误的异常。</span><br><span class="line">tips： 每个方法只执行一次。不会将方法返回的非原始类型值继续转换。</span><br></pre></td></tr></table></figure><p>举个例子说明下，参考于<a href="https://www.zhihu.com/question/277243339/answer/392788506" target="_blank" rel="noopener">知乎</a>:</p><p><img src="https://user-gold-cdn.xitu.io/2018/5/17/1636be8859e9af36?w=872&amp;h=1310&amp;f=png&amp;s=175704" alt=""></p><p>原始数据类型(string,number,boolean,null, undefined,symbol)。<br>复杂数据类型(Object, Function, Array, Date, …)<br>基础数据类型的比较，是值的比较，Object对象的比较，则是引用的比较</p><p>相等操作符(<code>==</code>)，经过类型转换之后，才比较他们的值或者对象值。<br>对于全等操作符(<code>===</code>)，等号两边的值和类型，必须完全相等。</p><h2 id="为什么建议使用"><a href="#为什么建议使用" class="headerlink" title="为什么建议使用 ==="></a>为什么建议使用 <code>===</code></h2><h3 id="1-review代码时候，增加理解时间"><a href="#1-review代码时候，增加理解时间" class="headerlink" title="1. review代码时候，增加理解时间"></a>1. review代码时候，增加理解时间</h3><p>在使用了 <code>==</code>的表达式中，我们需要先理解作者的意图。</p><ul><li>想当然的以为都可以。</li><li>确实需要通过类型转换来判断。</li><li>不应该类型转换，但是写错了。</li></ul><h3 id="2-会判断错误"><a href="#2-会判断错误" class="headerlink" title="2. 会判断错误"></a>2. 会判断错误</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let num = 2</span><br><span class="line">let obj = &#123;</span><br><span class="line">  valueOf: function() &#123;</span><br><span class="line">    return 2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(obj == 2)</span><br></pre></td></tr></table></figure><p>输出<code>true</code>，<br>我们本意是这两者<code>!=</code>，而这里得到的结果是<code>==</code>，这不是我们想要的结果。</p><h3 id="3-会产生异常"><a href="#3-会产生异常" class="headerlink" title="3. 会产生异常"></a>3. 会产生异常</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let num = 2</span><br><span class="line">let obj = &#123;</span><br><span class="line">  valueOf: function() &#123;</span><br><span class="line">    return &#123;&#125;</span><br><span class="line"> &#125;,</span><br><span class="line"> toString: function() &#123;</span><br><span class="line">  return &#123;&#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(obj === 2)</span><br><span class="line">console.log(obj == 2)</span><br></pre></td></tr></table></figure><p>第一行输出：<code>false</code><br>第二行输出错误提示：<code>Uncaught TypeError: Cannot convert object to primitive value</code></p><p>通过前面类型转换，可以得知，一般情况下，对象会先转换为原始值。<br>而其过程是通过自带的<code>valueOf()/toString()</code>先转换为primitive value，再和其他值做比较。<br>而在这里，我们手动将obj对象的<code>valueOf()/toString()</code>覆盖了，导致无法实现转换为原始值。</p><p>一般情况下，建议使用<code>===</code> ，除非你了解，确实需要类型转换，才使用 <code>==</code></p><h2 id="条件表达式语句（if、三目运算等）"><a href="#条件表达式语句（if、三目运算等）" class="headerlink" title="条件表达式语句（if、三目运算等）"></a>条件表达式语句（if、三目运算等）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (condition) &#123;</span><br><span class="line">    statement1 </span><br><span class="line">&#125; else &#123;</span><br><span class="line">    statement2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是if语句的基础用法。通过判断<code>condition</code>的布尔值，来决定执行<code>statement1</code>代码块1，还是执行<code>statement2</code>代码块2。<br>先看下面的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var s = &apos;str&apos;</span><br><span class="line">var blT = true</span><br><span class="line">var blF = false</span><br><span class="line">if (s) &#123;</span><br><span class="line">    console.log(&apos;正确&apos;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    console.log(&apos;错误&apos;)</span><br><span class="line">&#125;</span><br><span class="line">console.log(s == blT)</span><br></pre></td></tr></table></figure></p><p>以上语句，得到的结果是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">正确</span><br><span class="line">false</span><br></pre></td></tr></table></figure></p><p>为什么if语句，会执行第一个代码块。而<code>s == blT</code>  却是false呢？<br>其实，这个就涉及到类型转换的问题了。<br>输出<code>“正确”</code>：</p><ul><li>if语句的条件表达式，会自动调用<code>Boolean()</code>转换函数，将这个表达式的结果转换为一个布尔值。</li><li>Boolean(‘str’) = true</li></ul><p>输出<code>false</code>：</p><ul><li>根据在上面类型转换那部分所讲，会先调用<code>Number()</code>转换函数转换为数值，之后再比较。</li><li>Number(‘str’) = NaN</li><li>Number(true) = 1</li></ul><h2 id="图表举例列出常见对象相等情况"><a href="#图表举例列出常见对象相等情况" class="headerlink" title="图表举例列出常见对象相等情况"></a>图表举例列出常见对象相等情况</h2><p><a href="https://codepen.io/weiqinl/pen/YaovMp" target="_blank" rel="noopener">普通相等</a><br><a href="https://codepen.io/weiqinl/details/KojBPb" target="_blank" rel="noopener">完全相等</a></p><p>【完】</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript 有两种比较方式：严格比较运算符和转换类型比较运算符。&lt;br&gt;在相等运算符中对应 &lt;code&gt;===&lt;/code&gt; 、&lt;code&gt;!==&lt;/code&gt;和 &lt;code&gt;==&lt;/code&gt;、&lt;code&gt;!=&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;先举个栗子&quot;&gt;&lt;a href=&quot;#先举个栗子&quot; class=&quot;headerlink&quot; title=&quot;先举个栗子&quot;&gt;&lt;/a&gt;先举个栗子&lt;/h2&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; str = &lt;span class=&quot;string&quot;&gt;&#39;1&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; num0 = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; num1 = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; blT = &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; blF = &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; nul = &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; und = &lt;span class=&quot;literal&quot;&gt;undefined&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(str == num1) &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(str == blT) &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(blT == num1) &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(blF == num0) &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(nul == und) &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(str === num1) &lt;span class=&quot;comment&quot;&gt;// false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(str === blT) &lt;span class=&quot;comment&quot;&gt;// false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(blT === num1) &lt;span class=&quot;comment&quot;&gt;// false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(blF === num0) &lt;span class=&quot;comment&quot;&gt;// false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(nul === und) &lt;span class=&quot;comment&quot;&gt;// false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;相等操作符(&lt;code&gt;==&lt;/code&gt;)会为两个不同类型的操作数进行类型转换，然后进行严格比较。&lt;br&gt;严格相等操作符(&lt;code&gt;===&lt;/code&gt;),一般也叫做全等操作符。会先判断类型，再比较值是否相等。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://weiqinl.com/tags/javascript/"/>
    
      <category term="数据类型" scheme="http://weiqinl.com/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Javascript数据类型的非常6+1</title>
    <link href="http://weiqinl.com/2018/04/17/Javascript%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%9D%9E%E5%B8%B86-1/Javascript%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%9D%9E%E5%B8%B86-1/"/>
    <id>http://weiqinl.com/2018/04/17/Javascript数据类型的非常6-1/Javascript数据类型的非常6-1/</id>
    <published>2018-04-17T03:16:01.000Z</published>
    <updated>2018-04-17T07:19:39.671Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态类型"><a href="#动态类型" class="headerlink" title="动态类型"></a>动态类型</h1><p>JavaScript是一种弱类型或者说动态语言。这意味着你不用提前声明变量的类型，在程序运行过程中，类型会被自动确定。这也意味着你可以使用同一个变量保存不同类型的数据</p><p><img src="/2018/04/17/Javascript数据类型的非常6-1/Javascript数据类型的非常6-1/images/43331776.png" alt="数据测试图1"><br><img src="/2018/04/17/Javascript数据类型的非常6-1/Javascript数据类型的非常6-1/43331776.png" alt="数据测试图2"></p><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>最新的ECMAScript标准定义了7种数据类型；<br>其中六种基础数据类型(primitive type)：Undefined、Null、Boolean、Number、String、Symbol(es6 新增）。<br>一种引用类型：Object。<br><a id="more"></a></p><p>使用<code>typeof</code>运算符来判断一个值是否在某种类型的范围内。可以用这种运算符判断一个值是否表示一种原始类型：如果它是原始类型，还可以判断它表示哪种原始类型。<br>使用<code>instanceof</code>运算符用来测试一个对象在其原型链中是否存在一个构造函数的 <code>prototype</code> 属性。</p><p>以下，我们分别看看，基础数据类型有哪些特性，引用类型如何存储判断的。</p><h2 id="原始值"><a href="#原始值" class="headerlink" title="原始值"></a>原始值</h2><p><strong>除 Object 以外的所有类型的值本身无法被改变，我们称这些类型的值为 <code>原始值</code></strong>。<br>大多数时候，原始值直接代表语言实现的最底层。<br>原始值是存储在栈(stack)中的简单数据段，也就是说，它们的值直接存储在变量访问的位置。</p><p>ECMA-262把术语类型(type)定义为值的一个集合，每种基础数据类型定义了它包含的值的范围及其字面量表示形式。</p><h3 id="Undefined-类型"><a href="#Undefined-类型" class="headerlink" title="Undefined 类型"></a>Undefined 类型</h3><p>Undefined类型只有一个值，即<code>undefined</code>。当声明的变量未初始化时，该变量的默认值为<code>undefined</code>。<br><img src="/2018/04/17/Javascript数据类型的非常6-1/Javascript数据类型的非常6-1/33567909.png" alt="数据测试图-undefined"></p><p>声明的oTemp变量，没有初始值。该变量将被赋予值undefined，即undefined类型的字面量。<br>oTemp1没有定义，导致报 引用错误。</p><h3 id="Null类型"><a href="#Null类型" class="headerlink" title="Null类型"></a>Null类型</h3><p>Null类型只有一个值： <code>null</code>。值<code>null</code>是一个JavaScript字面量，表示空值(null or an “empty” value)，即没有对象被呈现。<br><img src="/2018/04/17/Javascript数据类型的非常6-1/Javascript数据类型的非常6-1/52190561.png" alt="数据测试图-null"></p><p>在这里要说明的是：在JavaScript中，null是基础数据类型，但是typeof判断为object，这是由于历史原因造成的。<br>在JavaScript最初的实现中，JavaScript中的值是由一个表示类型的标签和实际数据值表示的。对象的类型标签是0。由于<code>null</code>代表的是空指针(大多数平台下值为0x00），因此，null使用0作为类型标签，<code>typeof null</code>就返回了”object”。</p><h3 id="Boolean-布尔类型"><a href="#Boolean-布尔类型" class="headerlink" title="Boolean 布尔类型"></a>Boolean 布尔类型</h3><p>布尔表示一个逻辑实体，可以有两个值： <code>true</code> 和 <code>false</code>。<br><img src="/2018/04/17/Javascript数据类型的非常6-1/Javascript数据类型的非常6-1/55328415.png" alt="数据测试图-Boolean 布尔类型"></p><p>注意点：<br>由于js中区分大小写，因此<code>True</code> 和 <code>False</code> 都不是<code>Boolean</code>值。</p><p>任意的JavaScript的值都可以转换为布尔值。<code>undefined</code>,<code>null</code>, <code>0</code>,<code>-0</code>,<code>NaN</code>,<code>&quot;&quot;</code>这6个值,再加上<code>false</code>本身共7个值都会转换为<code>false</code></p><h3 id="Number-数字类型"><a href="#Number-数字类型" class="headerlink" title="Number 数字类型"></a>Number 数字类型</h3><p>在JavaScript中只有一种数字类型：基于IEEE 754 标准的双精度64位二进制格式的值（ -(253 -1) 到  253 -1）。这种类型可以表示32位的整数，也可以表示64位的浮点数，还能有一些带符号的值：<code>+Infinity</code>,<code>-Infinity</code>和<code>NaN</code>(非数值，Not-a-Number)。<br>直接输入的任何数字都可以看做Number类型的字面量。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var iNum = 86;  // 此代码声明了存放整数值的变量，它的值由字面量86定义。</span><br></pre></td></tr></table></figure></p><h4 id="进制数"><a href="#进制数" class="headerlink" title="进制数"></a>进制数</h4><p>通常，我们所说的整数都是以十进制来表示。但是，在计算机学科，也有其他进制，比如二进制、八进制、十六进制。<br>在JavaScript中，能准确识别十进制，十六进制整数。八进制整数要看情况识别。<br>八进制字面量的首数字必须是0，其后的数字可以是任何八进制数字(0-7)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var iNum = 070; // 070 等于十进制的 56</span><br></pre></td></tr></table></figure></p><p>虽然JavaScript的某些实现可以允许采用八进制形式表示整数。但是，ECMAScript 6的严格模式下，八进制字面量是明令禁止的。因此，最好不要使用以0位前缀的整型字面量。<br>十六进制字面量的首数字必须是0，后面接字母x，然后是任意的十六进制数字（0 到 9 和 A 到 F）。这些字母可以是大写的，也可以是小写的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var iNum = 0x1f; // 0x1f 等于十进制的 31</span><br><span class="line">var iMum = 0xAB; // 0xAB 等于十进制的 171</span><br></pre></td></tr></table></figure></p><p><strong>注意</strong>：尽管所有整数都可以表示为八进制或十六进制的字面量，但所有数学运算返回的都是十进制结果。</p><h4 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h4><p>要定义浮点值，必须包括小数点和小数点后的一位数字（例如，用1.0而不是1）。这被看作浮点数字面量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var fNum = 5.0;</span><br></pre></td></tr></table></figure></p><p><strong>对于浮点字面量，在用它进行计算前，真正存储的是字符串 </strong></p><p>JavaScript中的数字具有足够的精度，并可以极其近似于0.1。但是，数字不能精确表述也会带来一些问题。<br><img src="/2018/04/17/Javascript数据类型的非常6-1/Javascript数据类型的非常6-1/41773983.png" alt="数据测试图-浮点数"></p><p>由于四舍五入误差，上述代码中的”x” 实际上并不等于 “y”。这个问题，在任何使用二进制浮点数的编程语言中都会出现。不过，上述代码中的x和y的值非常接近彼此和最终的正确值。这种结果可以胜任大多数计算任务。不相等的问题只有在比较的时候才会出现。</p><h4 id="特殊的Number值"><a href="#特殊的Number值" class="headerlink" title="特殊的Number值"></a>特殊的Number值</h4><p><code>Number对象</code>是经过封装的能让你处理数字值的对象。它由<code>Number()</code>构造器创建。<code>Number对象</code>的属性都是<code>Number</code>类型。比如，前两个是<code>Number.MAX_VALUE</code> 和 <code>Number.MIN_VALUE</code>。它们定义了<code>Number</code>值集合的外边界。<code>Number.MIN_SAFE_INTEGER</code>和<code>Number.MAX_SAFE_INTEGER</code>，分别表示最小的安全整数，最大的安全整数。<br><code>Number.NaN</code>表示特殊的”非数字”值。以下是一些例子：<br><img src="/2018/04/17/Javascript数据类型的非常6-1/Javascript数据类型的非常6-1/49428673.png" alt="数据测试图-特殊的Number值"></p><h4 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h4><p><code>NaN</code> 是一个奇怪的特殊值。一般来说，这种情况发生在类型转换失败时。例如，要把单词 blue 转换成数值就会失败，因为没有与之等价的数值。与无穷大一样，<code>NaN</code>也不能用于算术计算。<code>NaN</code>的另一个奇特之处在于，它与自身不相等，这意味着下面的代码将返回false;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(NaN == NaN); // false</span><br></pre></td></tr></table></figure></p><p>出于这个原因，不推荐使用  <code>NaN</code> 值本身。建议使用函数<code>Number.isNaN()</code>或者 <code>isNaN()</code>：<br><code>isNaN()</code>是全局函数，会强制将参数转换为数字，用来确定一个值是否为<code>NaN</code>，<br>es6中定义的<code>Number.isNaN()</code>函数，不会强制将参数转换为数字，只有在参数是真正的数字类型，且值为<code>NaN</code>的时候才会返回<code>true</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">alert(Number.isNaN(&apos;blue&apos;)); // false</span><br><span class="line">alert(isNaN(&apos;blue&apos;)); // true</span><br><span class="line">alert(Number.isNaN(666)); // false</span><br><span class="line">alert(isNaN(666)); // false</span><br><span class="line">alert(Number.isNaN(0 / 0)); // true</span><br><span class="line">alert(isNaN(0 / 0); // true</span><br></pre></td></tr></table></figure></p><p><img src="/2018/04/17/Javascript数据类型的非常6-1/Javascript数据类型的非常6-1/58823483.png" alt="数据测试图-NaN"></p><h3 id="String-字符串类型"><a href="#String-字符串类型" class="headerlink" title="String 字符串类型"></a>String 字符串类型</h3><p>JavaScript的字符串类型用于表示文本数据。它是一组16位的无符号整数值的“元素”。在字符串种的每个元素占据了字符串的位置。第一个元素的索引为0，下一个是索引1，依此类推。字符串的长度是它的元素的数量。<br>字符串类型有个特色叫<code>immutable</code>，这意味着字符串一旦被创建，本身是不能被修改的。当使用<code>String.prototype.methods</code>做任何操作都不会影响到原字符串，但是，可以基于对原始字符串的操作来创建新的字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var str = &quot;test&quot;</span><br><span class="line">str.len = 4   //  这里修改的只是临时对象，之后立马销毁</span><br><span class="line">var t = str.len</span><br><span class="line">console.log(t); // 由于str没有len这个属性，所有会输出 undefined</span><br></pre></td></tr></table></figure></p><p><img src="/2018/04/17/Javascript数据类型的非常6-1/Javascript数据类型的非常6-1/36709921.png" alt="数据测试图-String 字符串类型"></p><h3 id="Symbol-符号类型"><a href="#Symbol-符号类型" class="headerlink" title="Symbol 符号类型"></a>Symbol 符号类型</h3><p>符号(Symbols)是ECMAScript 6新定义的。<code>Symbol()</code>函数返回<code>symbol</code>类型的值，都是唯一的，不相等的，并且具有静态属性和静态方法。<code>symbol值</code>可以用来作为对象属性的标识符，这是<code>Symbol数据类型</code>的唯一目的。<br>在某些语言中也有类似原子类型(Atoms)，你也可以认为它们是C里面的枚举类型。<br><img src="/2018/04/17/Javascript数据类型的非常6-1/Javascript数据类型的非常6-1/48199609.png" alt="数据测试图-Symbol 符号类型"></p><h2 id="Objects"><a href="#Objects" class="headerlink" title="Objects"></a>Objects</h2><p>与原始类型对应的是引用类型。引用类型通常叫做类(class)，也就是说，遇到引用值，所处理的就是对象。</p><p>引用值是存储在堆(heap)中的对象，也就是说，存储在变量处的值是一个指针(point)，指向存储对象的内存处。<br>在内存中可以被 标识符引用的一块区域。</p><p>ECMAScript中的所有对象都由这个对象继承而来，Object对象中的所有属性和方法都会出现在其他对象中。</p><p><strong>数组</strong>、<strong>对象</strong>、<strong>函数</strong>等都被称为复杂对象。</p><p>参考： </p><ol><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures" target="_blank" rel="noopener">JavaScript数据类型和数据结构</a></li><li><a href="http://www.w3school.com.cn/js/pro_js_primitivetypes.asp" target="_blank" rel="noopener">ECMAScript原始类型</a></li><li><a href="http://www.w3school.com.cn/js/pro_js_referencetypes.asp" target="_blank" rel="noopener">ECMAScript引用类型</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;动态类型&quot;&gt;&lt;a href=&quot;#动态类型&quot; class=&quot;headerlink&quot; title=&quot;动态类型&quot;&gt;&lt;/a&gt;动态类型&lt;/h1&gt;&lt;p&gt;JavaScript是一种弱类型或者说动态语言。这意味着你不用提前声明变量的类型，在程序运行过程中，类型会被自动确定。这也意味着你可以使用同一个变量保存不同类型的数据&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2018/04/17/Javascript数据类型的非常6-1/Javascript数据类型的非常6-1/images/43331776.png&quot; alt=&quot;数据测试图1&quot;&gt;&lt;br&gt;&lt;img src=&quot;/2018/04/17/Javascript数据类型的非常6-1/Javascript数据类型的非常6-1/43331776.png&quot; alt=&quot;数据测试图2&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;数据类型&quot;&gt;&lt;a href=&quot;#数据类型&quot; class=&quot;headerlink&quot; title=&quot;数据类型&quot;&gt;&lt;/a&gt;数据类型&lt;/h1&gt;&lt;p&gt;最新的ECMAScript标准定义了7种数据类型；&lt;br&gt;其中六种基础数据类型(primitive type)：Undefined、Null、Boolean、Number、String、Symbol(es6 新增）。&lt;br&gt;一种引用类型：Object。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://weiqinl.com/tags/javascript/"/>
    
      <category term="数据类型" scheme="http://weiqinl.com/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript对象的valueOf()方法</title>
    <link href="http://weiqinl.com/2018/03/31/JavaScript%E5%AF%B9%E8%B1%A1%E7%9A%84valueOf-%E6%96%B9%E6%B3%95/"/>
    <id>http://weiqinl.com/2018/03/31/JavaScript对象的valueOf-方法/</id>
    <published>2018-03-31T02:08:52.000Z</published>
    <updated>2018-04-17T03:13:40.035Z</updated>
    
    <content type="html"><![CDATA[<p>js对象中的<code>valueOf()</code>方法和<code>toString()</code>方法非常类似，但是，当需要返回对象的原始值而非字符串的时候才调用它，尤其是转换为数字的时候。如果在需要使用原始值的上下文中使用了对象，JavaScript就会自动调用<code>valueOf()</code>方法。</p><p><code>valueOf()</code>方法是<code>Object</code>的原型方法，每个对象都具有该方法，但是各对象返回的值有一定的区别。我们一起来看看。 </p><h2 id="Object-prototype-valueOf"><a href="#Object-prototype-valueOf" class="headerlink" title="Object.prototype.valueOf()"></a>Object.prototype.valueOf()</h2><p>JavaScript调用<code>valueOf()</code>方法将对象转换为原始值。你很少需要自己调用<code>valueOf()</code>方法； </p><p>默认情况下，<code>valueOf()</code>方法由Object后面的每个对象继承。每个内置的核心对象都会覆盖此方法以放回适当的值。<br>如果对象没有原始值，则<code>valueOf()</code>将返回对象本身。</p><p>你可以在自己的代码中使用<code>valueOf()</code>将内置对象转换为原始值。创建自定义对象时，可以覆盖<code>Object.prototype.valueOf()</code>来调用自定义方法，而不是默认<code>Object</code>方法。</p><h3 id="覆盖自定义对象的valueOf-方法"><a href="#覆盖自定义对象的valueOf-方法" class="headerlink" title="覆盖自定义对象的valueOf()方法"></a>覆盖自定义对象的<code>valueOf()</code>方法</h3><p>你可以创建一个取代<code>valueOf()</code>方法的函数，你的方法必须不能传入参数。<br>假设你有个对象叫<code>MyNumberType</code>而你想为它创建一个<code>valueOf()</code>方法。下面的代码为<code>valueOf()</code>方法赋予了一个自定义函数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyNumberType.prototype.valueOf = function() &#123; return customPrimitiveValue; &#125;;</span><br></pre></td></tr></table></figure></p><p>有了这样的一个方法，下一次每当<code>MyNumberType</code>要被转换为原始类型值时，JavaScript在此之前会自动调用自定义的<code>valueOf()</code>方法。<br><code>valueOf()</code>方法一般都会被JavaScript自动调用，但你也可以像下面代码那样自己调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myNumberType.valueOf()</span><br></pre></td></tr></table></figure></p><h2 id="String-prototype-valueOf"><a href="#String-prototype-valueOf" class="headerlink" title="String.prototype.valueOf()"></a>String.prototype.valueOf()</h2><p>语法：<code>strObj.valueOf()</code><br>返回值：表示给定<code>String</code>对象的原始值<br>说明：<code>valueOf()</code>方法返回一个<code>String</code>对象的原始值，该值等同于<code>String.prototype.toString()</code>。<br>该方法通常在JavaScript内部被调用，而不是在代码里显示调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let x = new String(&apos;Hello world&apos;)</span><br><span class="line">console.log(x.valueOf())   // Hello world</span><br></pre></td></tr></table></figure></p><p><img src="http://images2017.cnblogs.com/blog/564792/201801/564792-20180129235451546-2056772811.png" alt="String.prototype.valueOf()"></p><h2 id="Date-prototype-valueOf"><a href="#Date-prototype-valueOf" class="headerlink" title="Date.prototype.valueOf()"></a>Date.prototype.valueOf()</h2><p>语法：<code>dataObj.valueOf()</code><br>返回值：表示给定<code>Date</code>对象的原始值<br>说明：<code>valueOf()</code>方法返回以数值格式表示的一个<code>Date</code>对象的原始值。该值从1970年1月1日0时0分0秒（UTC，即协调世界时）到该日期对象所代表时间的毫秒数。<br>该方法的功能和<code>Date.prototype.getTime()</code>方法一样。<br>该方法通常在JavaScript内部调用，而不是在代码中显示调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var x = new Date(2018, 1, 12)</span><br><span class="line">var myVar = x.valueOf()</span><br><span class="line">console.log(myVar) // 1518364800000</span><br></pre></td></tr></table></figure><h2 id="Number-prototype-valueOf"><a href="#Number-prototype-valueOf" class="headerlink" title="Number.prototype.valueOf()"></a>Number.prototype.valueOf()</h2><p>语法： <code>numObj.valueOf()</code><br>返回值：表示给定<code>Number</code>对象的原始值。<br>说明：该方法通常在JavaScript内部调用，而不是在代码中显示调用。覆盖<code>Object.prototype.valueOf()</code>方法<br>案例：<br><img src="http://images2017.cnblogs.com/blog/564792/201801/564792-20180129235430343-552143799.png" alt="Number.prototype.valueOf()"></p><h2 id="Boolean-prototype-valueOf"><a href="#Boolean-prototype-valueOf" class="headerlink" title="Boolean.prototype.valueOf()"></a>Boolean.prototype.valueOf()</h2><p>语法：<code>bool.valueOf()</code><br>返回值： 返回给定<code>Boolean</code>对象的原始值<br>说明： <code>Boolean</code>的<code>valueOf()</code>方法返回一个<code>Boolean</code>字面量的原始值作为布尔数据类型。该方法通常在JavaScript内部调用，而不是在代码中显示调用。<br>案例：<br><img src="http://images2017.cnblogs.com/blog/564792/201801/564792-20180129235413140-100092005.png" alt="Boolean.prototype.valueOf()"></p><h2 id="Symbol-prototype-valueOf"><a href="#Symbol-prototype-valueOf" class="headerlink" title="Symbol.prototype.valueOf()"></a>Symbol.prototype.valueOf()</h2><p>语法： <code>Symbol().valueOf()</code><br>返回值：返回给定<code>Symbol</code>对象的原始值<br>说明：<code>Symbol</code>的<code>valueOf()</code>方法返回<code>Symbol</code>对象的原始值作为<code>Symbol</code>数据类型。JavaScript调用<code>valueOf()</code>方法将对象转换为原始值。你很少需要自己调用<code>valueOf()</code>方法。当遇到期望有原始值的对象时，JavaScript会自动调用它。<br>案例：<br><img src="http://images2017.cnblogs.com/blog/564792/201801/564792-20180129235355750-1139685875.png" alt=" Symbol.prototype.valueOf()"><br>[完]</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;js对象中的&lt;code&gt;valueOf()&lt;/code&gt;方法和&lt;code&gt;toString()&lt;/code&gt;方法非常类似，但是，当需要返回对象的原始值而非字符串的时候才调用它，尤其是转换为数字的时候。如果在需要使用原始值的上下文中使用了对象，JavaScript就会自动调用
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>mac通过自带的ssh连接Linux服务器并上传解压文件</title>
    <link href="http://weiqinl.com/2018/01/27/mac%E9%80%9A%E8%BF%87%E8%87%AA%E5%B8%A6%E7%9A%84ssh%E8%BF%9E%E6%8E%A5Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B9%B6%E4%B8%8A%E4%BC%A0%E8%A7%A3%E5%8E%8B%E6%96%87%E4%BB%B6/"/>
    <id>http://weiqinl.com/2018/01/27/mac通过自带的ssh连接Linux服务器并上传解压文件/</id>
    <published>2018-01-27T05:48:46.000Z</published>
    <updated>2018-04-17T03:13:40.038Z</updated>
    
    <content type="html"><![CDATA[<h1 id="需求："><a href="#需求：" class="headerlink" title="需求："></a>需求：</h1><p>1：mac连接linux服务器<br>2：将mac上的文件上传到linux服务器指定位置<br>3：解压文件<br>mac上使用命令，推荐使用 <a href="https://www.iterm2.com/downloads.html" target="_blank" rel="noopener">iterm2</a> 。当然，也可以使用mac自带的终端工具。<br><a id="more"></a></p><h1 id="操作过程："><a href="#操作过程：" class="headerlink" title="操作过程："></a>操作过程：</h1><h2 id="一：-mac连接linux服务器"><a href="#一：-mac连接linux服务器" class="headerlink" title="一： mac连接linux服务器"></a>一： mac连接linux服务器</h2><p>输入命令连接Linux服务器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh username@ip</span><br></pre></td></tr></table></figure></p><p>其中: username为登录Linux服务器所需的用户名，ip为服务器的地址。默认端口号为22，如果要指定端口号，使用 -p port<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 以下两种方式都可以</span><br><span class="line">ssh username@ip -p port </span><br><span class="line">ssh -p port username@ip</span><br></pre></td></tr></table></figure></p><p>回车，它会要求输入密码，说明以上步骤没有错。输入密码，如果顺利，连上了Linux服务器。<br>以下，我第一次输入错误密码的提示。第二次密码正确。<br><img src="http://images2017.cnblogs.com/blog/564792/201801/564792-20180127132751803-1806625861.png" alt="mac通过ssh连接linux服务器"></p><p>此时，就算是连上了linux服务器。</p><h2 id="二：-上传文件到linux服务器"><a href="#二：-上传文件到linux服务器" class="headerlink" title="二： 上传文件到linux服务器"></a>二： 上传文件到linux服务器</h2><p><strong>新开一个窗口</strong> 使用scp命令<br>scp是secure copy的缩写，scp是linux系统下基于ssh登录进行安全的远程文件拷贝命令。<br>介绍一个命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp [-r] [-P port] local_file_address username@ip:remote_file_address</span><br></pre></td></tr></table></figure></p><p>命令解释：<br>-r: 递归复制整个目录<br>-P port: 注意是大写的P，port是指定的端口号。<br>local_file_address:  本地文件地址。[地址是根据当前命令所在目录来编写的]<br>remote_file_address: 远程服务器地址。<br>输入完以上命令，回车，之后会让你输入服务器密码。成功之后，就开始复制了。以下是我的一个操作。<br><img src="http://images2017.cnblogs.com/blog/564792/201801/564792-20180127133041256-482599300.png" alt="scp远程文件拷贝命令"></p><h2 id="三：解压文件"><a href="#三：解压文件" class="headerlink" title="三：解压文件"></a>三：解压文件</h2><p>连接好Linux服务器后，找到要解压的文件目录地址。<br><code>unzip</code>命令用于解压缩由<code>zip</code>命令压缩的<code>.zip</code>压缩包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unzip test.zip  // 将压缩文件test.zip在当前目录下解压缩。</span><br><span class="line">unzip -n test.zip -d /tmp // 将压缩文件text.zip在指定目录/tmp下解压缩，如果已有相同的文件存在，要求unzip命令不覆盖原先的文件。</span><br></pre></td></tr></table></figure><p>参考：<br>1：主要参考：<a href="http://blog.csdn.net/fuyujiaof/article/details/56487525" target="_blank" rel="noopener">http://blog.csdn.net/fuyujiaof/article/details/56487525</a><br>2：scp 命令： <a href="http://www.runoob.com/linux/linux-comm-scp.html" target="_blank" rel="noopener">http://www.runoob.com/linux/linux-comm-scp.html</a><br>3：unzip命令： <a href="http://man.linuxde.net/unzip" target="_blank" rel="noopener">http://man.linuxde.net/unzip</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;需求：&quot;&gt;&lt;a href=&quot;#需求：&quot; class=&quot;headerlink&quot; title=&quot;需求：&quot;&gt;&lt;/a&gt;需求：&lt;/h1&gt;&lt;p&gt;1：mac连接linux服务器&lt;br&gt;2：将mac上的文件上传到linux服务器指定位置&lt;br&gt;3：解压文件&lt;br&gt;mac上使用命令，推荐使用 &lt;a href=&quot;https://www.iterm2.com/downloads.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;iterm2&lt;/a&gt; 。当然，也可以使用mac自带的终端工具。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="mac" scheme="http://weiqinl.com/tags/mac/"/>
    
      <category term="linux" scheme="http://weiqinl.com/tags/linux/"/>
    
      <category term="上传文件" scheme="http://weiqinl.com/tags/%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>CSS3 box-shadow 内外阴影效果</title>
    <link href="http://weiqinl.com/2017/12/14/CSS3-box-shadow-%E5%86%85%E5%A4%96%E9%98%B4%E5%BD%B1%E6%95%88%E6%9E%9C/"/>
    <id>http://weiqinl.com/2017/12/14/CSS3-box-shadow-内外阴影效果/</id>
    <published>2017-12-14T07:54:45.000Z</published>
    <updated>2018-04-17T03:13:40.032Z</updated>
    
    <content type="html"><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>box-shadow 属性可以给元素边框周围添加一个或者多个阴影效果。定义多个阴影，使用逗号分隔。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p><code>box-shadow: none | [inset? &amp;&amp; [&lt;offset-x&gt; &lt;offset-y&gt; &lt;blur-radius&gt;? &lt;spread-radius&gt;? &amp;&amp; &lt;color&gt;? ] ]</code></p><a id="more"></a><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><p><code>none</code>：默认值为none，表示没有阴影<br><code>inset</code>：<strong>可选</strong>。将边框外阴影改为边框内阴影（即使是透明边框），背景之上内容之下。如果不写，默认为边框外阴影。inset只可写在最前或者最后。<br><code>offset-x</code>：<strong>必需</strong>。阴影水平方向的偏移量。 0，表示阴影在元素后面；正值，表示阴影在元素右边👉；负值，表示阴影在元素左边👈<br><code>offset-y</code>：<strong>必需</strong>。阴影垂直方向的偏移量。   0，表示阴影在元素后面；正值，表示阴影在元素下边☟；负值，表示阴影在元素上边☝<br><code>blur-radius</code>：<strong>可选</strong>。阴影的模糊距离。<strong>不允许为负值</strong>。如果值为0，则阴影的边缘清晰，否则，值越大，阴影的边缘越模糊。<br><code>spread-radius</code>：<strong>可选</strong>。默认为0，此时阴影与元素同样大；正直，阴影向各个方向延伸扩大；负值，阴影沿相反方向缩小。<br><code>color</code>：<strong>可选</strong>。如果没有指定，使用浏览器默认颜色–通常是<code>color</code>属性的值。  </p><h2 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h2><p>注意：以下例子不是截图</p><h3 id="正常情况"><a href="#正常情况" class="headerlink" title="正常情况"></a>正常情况</h3><p><code>&lt;p style=&#39;width:80%; border: 1px solid #ccc; box-shadow:15px 5px blue&#39;&gt;css阴影&lt;/p&gt;</code></p><p style="width:80%; border: 1px solid #ccc; box-shadow:15px 5px blue">css阴影 box-shadow:15px 5px blue</p><p><code>&lt;p style=&#39;width:80%; border: 1px solid #ccc; box-shadow:15px 5px 10px blue&#39;&gt;css阴影&lt;/p&gt;</code>  </p><p style="width:80%; border: 1px solid #ccc; box-shadow:15px 5px 10px blue">css阴影 box-shadow:15px 5px 10px blue</p><p><code>&lt;p style=&#39;width:80%; border: 1px solid #ccc; box-shadow:15px 5px 10px 5px blue&#39;&gt;css阴影&lt;/p&gt;</code></p><p style="width:80%; border: 1px solid #ccc; box-shadow:15px 5px 10px 5px blue">css阴影 box-shadow:15px 5px 10px 5px blue</p><p><code>&lt;p style=&#39;width:80%; border: 1px solid #ccc; box-shadow:15px 5px 0px 5px blue&#39;&gt;css阴影&lt;/p&gt;</code></p><p style="width:80%; border: 1px solid #ccc; box-shadow:15px 5px 0px 5px blue">css阴影 box-shadow:15px 5px 0px 5px blue</p><h3 id="负值-blur-radius不允许为负值，其他三个可以"><a href="#负值-blur-radius不允许为负值，其他三个可以" class="headerlink" title="负值 (blur-radius不允许为负值，其他三个可以)"></a>负值 (blur-radius不允许为负值，其他三个可以)</h3><p><code>&lt;p style=&#39;width:80%; border: 1px solid #ccc; box-shadow:15px -5px blue&#39;&gt;css阴影&lt;/p&gt;</code></p><p style="width:80%; border: 1px solid #ccc; box-shadow:15px -5px blue">css阴影 box-shadow:15px -5px blue</p><p><code>&lt;p style=&#39;width:80%; border: 1px solid #ccc; box-shadow:-15px -5px blue&#39;&gt;css阴影&lt;/p&gt;</code></p><p style="width:80%; border: 1px solid #ccc; box-shadow:-15px -5px blue">css阴影 box-shadow:-15px -5px blue</p><p><code>&lt;p style=&#39;width:80%; border: 1px solid #ccc; box-shadow:-15px 5px blue&#39;&gt;css阴影&lt;/p&gt;</code></p><p style="width:80%; border: 1px solid #ccc; box-shadow:-15px 5px blue">css阴影 box-shadow:-15px 5px blue</p><p><code>&lt;p style=&#39;width:80%; border: 1px solid #ccc; box-shadow:15px 5px 10px -5px blue&#39;&gt;css阴影&lt;/p&gt;</code></p><p style="width:80%; border: 1px solid #ccc; box-shadow:15px 5px 10px -5px blue">css阴影 box-shadow:15px 5px 10px -5px blue</p><p><code>&lt;p style=&#39;width:80%; border: 1px solid #ccc; box-shadow:15px 5px 0px -5px blue&#39;&gt;css阴影&lt;/p&gt;</code></p><p style="width:80%; border: 1px solid #ccc; box-shadow:15px 5px 0px -5px blue">css阴影 box-shadow:15px 5px 0px -5px blue</p><h3 id="inset-内阴影"><a href="#inset-内阴影" class="headerlink" title="inset 内阴影"></a>inset 内阴影</h3><p><code>&lt;p style=&#39;width:80%; border: 1px solid #ccc; box-shadow:inset 15px 5px blue&#39;&gt;css阴影&lt;/p&gt;</code></p><p style="width:80%; border: 1px solid #ccc; box-shadow:inset 15px 5px blue">css阴影 box-shadow:inset 15px 5px blue</p><p><code>&lt;p style=&#39;width:80%; border: 1px solid #ccc; box-shadow:inset 15px 5px 10px blue&#39;&gt;css阴影&lt;/p&gt;</code></p><p style="width:80%; border: 1px solid #ccc; box-shadow:inset 15px 5px 10px blue">css阴影 box-shadow:inset 15px 5px 10px blue</p><p><code>&lt;p style=&#39;width:80%; border: 1px solid #ccc; box-shadow:inset 15px 5px 10px 5px blue&#39;&gt;css阴影&lt;/p&gt;</code></p><p style="width:80%; border: 1px solid #ccc; box-shadow:inset 15px 5px 10px 5px blue">css阴影 box-shadow:inset 15px 5px 10px 5px blue</p> <p><code>&lt;p style=&#39;width:80%; border: 1px solid #ccc; box-shadow:inset 15px 5px 0px 5px blue&#39;&gt;css阴影&lt;/p&gt;</code></p><p style="width:80%; border: 1px solid #ccc; box-shadow:inset 15px 5px 0px 5px blue">css阴影 box-shadow:inset 15px 5px 0px 5px blue</p><h3 id="多个阴影"><a href="#多个阴影" class="headerlink" title="多个阴影"></a>多个阴影</h3><p>多个阴影，写在前面的权重大，阴影重合部分权重大的值在上面。</p><p><code>&lt;p style=&#39;width:80%; border: 1px solid #ccc; box-shadow:15px 5px blue, -15px -5px red&#39;&gt;css阴影&lt;/p&gt;</code></p><p style="width:80%; border: 1px solid #ccc; box-shadow:15px 5px blue, -15px -5px red">css阴影 box-shadow:15px 5px blue, -15px -5px red</p><p><code>&lt;p style=&#39;width:80%; border: 1px solid #ccc; box-shadow:15px 0px 10px blue, -15px 0px 10px red, 0px 5px 10px yellow, 0px -5px 10px green &#39;&gt;css阴影&lt;/p&gt;</code></p><p style="width:80%; border: 1px solid #ccc; box-shadow:15px 0px 10px blue, -15px 0px 10px red, 0px 5px 10px yellow, 0px -5px 10px green ">css阴影 box-shadow:15px 0px 10px blue, -15px 0px 10px red, 0px 5px 10px yellow, 0px -5px 10px green </p><p><code>&lt;p style=&#39;width:80%; border: 1px solid #ccc; box-shadow:-15px -5px red inset,inset 15px 5px blue&#39;&gt;css阴影&lt;/p&gt;</code></p><p style="width:80%; border: 1px solid #ccc; box-shadow:-15px -5px red inset,inset 15px 5px blue">css阴影 box-shadow:-15px -5px red inset,inset 15px 5px blue</p><p><code>&lt;p style=&#39;width:80%; border: 1px solid #ccc; box-shadow:inset 15px 0px 10px blue, inset -15px 0px 10px red, inset 0px 5px 10px yellow, 0px -5px 10px green inset &#39;&gt;css阴影&lt;/p&gt;</code></p><p style="width:80%; border: 1px solid #ccc; box-shadow:inset 15px 0px 10px blue, inset -15px 0px 10px red, inset 0px 5px 10px yellow, 0px -5px 10px green inset ">css阴影 box-shadow:inset 15px 0px 10px blue, inset -15px 0px 10px red, inset 0px 5px 10px yellow, 0px -5px 10px green inset</p><h2 id="在线生成阴影值"><a href="#在线生成阴影值" class="headerlink" title="在线生成阴影值"></a>在线生成阴影值</h2><p>1：F12<img src="http://images2017.cnblogs.com/blog/564792/201712/564792-20171214154831888-1050223308.png" alt="开发者工具直接调试"></p><p>2: <a href="https://cssgenerator.org/box-shadow-css-generator.html" target="_blank" rel="noopener">Box Shadow CSS Generator</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上，基本用法已经会了。更复杂的情景，理解了应该很好写出来。在翻阅资料的时候，还看到了另一个属性 <code>filter:drop-shadow</code>，也表示阴影，但是有区别。<br><a href="http://www.zhangxinxu.com/wordpress/2016/05/css3-filter-drop-shadow-vs-box-shadow/" target="_blank" rel="noopener">CSS3 filter:drop-shadow滤镜与box-shadow区别应用</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h2&gt;&lt;p&gt;box-shadow 属性可以给元素边框周围添加一个或者多个阴影效果。定义多个阴影，使用逗号分隔。&lt;/p&gt;
&lt;h3 id=&quot;语法&quot;&gt;&lt;a href=&quot;#语法&quot; class=&quot;headerlink&quot; title=&quot;语法&quot;&gt;&lt;/a&gt;语法&lt;/h3&gt;&lt;p&gt;&lt;code&gt;box-shadow: none | [inset? &amp;amp;&amp;amp; [&amp;lt;offset-x&amp;gt; &amp;lt;offset-y&amp;gt; &amp;lt;blur-radius&amp;gt;? &amp;lt;spread-radius&amp;gt;? &amp;amp;&amp;amp; &amp;lt;color&amp;gt;? ] ]&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="css" scheme="http://weiqinl.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>html5原生拖拽/拖放 drag &amp; drop 详解</title>
    <link href="http://weiqinl.com/2017/12/07/html5%E5%8E%9F%E7%94%9F%E6%8B%96%E6%8B%BD-%E6%8B%96%E6%94%BE-drag-drop-%E8%AF%A6%E8%A7%A3/"/>
    <id>http://weiqinl.com/2017/12/07/html5原生拖拽-拖放-drag-drop-详解/</id>
    <published>2017-12-07T08:39:11.000Z</published>
    <updated>2018-04-17T03:13:40.037Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>拖放（drap &amp;&amp; drop）在我们平时的工作中，经常遇到。它表示：抓取对象以后拖放到另一个位置。目前，它是HTML5标准的一部分。我从几个方面学习并实践这个功能。</p><h2 id="拖放的流程对应的事件"><a href="#拖放的流程对应的事件" class="headerlink" title="拖放的流程对应的事件"></a>拖放的流程对应的事件</h2><p>我们先看下拖放的流程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">选中  ---&gt;  拖动  ---&gt; 释放</span><br></pre></td></tr></table></figure></p><p>然后，我们一步步看下这个过程中，会发生的事情。</p><h3 id="选中"><a href="#选中" class="headerlink" title="选中"></a>选中</h3><p>在HTML5标准中，为了使元素可拖动，把draggable属性设置为true。<br>文本、图片和链接是默认可以拖放的，它们的draggable属性自动被设置成了true。<br>图片和链接按住鼠标左键选中，就可以拖放。<br>文本只有在被选中的情况下才能拖放。如果显示设置文本的draggable属性为true，按住鼠标左键也可以直接拖放。</p><p>draggable属性：设置元素是否可拖动。<br>语法：<code>&lt;element draggable=&quot;true | false | auto&quot; &gt;</code></p><ul><li>true: 可以拖动  </li><li>false: 禁止拖动  </li><li>auto: 跟随浏览器定义是否可以拖动  </li></ul><a id="more"></a><h3 id="拖动"><a href="#拖动" class="headerlink" title="拖动"></a>拖动</h3><p>每一个可拖动的元素，在拖动过程中，都会经历三个过程，<code>拖动开始</code>–&gt;<code>拖动过程中</code>–&gt; <code>拖动结束</code>。</p><table><thead><tr><th style="text-align:center">针对对象</th><th style="text-align:left">事件名称</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">被拖动的元素</td><td style="text-align:left">dragstart</td><td style="text-align:center">在元素开始被拖动时候触发</td></tr><tr><td style="text-align:center"></td><td style="text-align:left">drag</td><td style="text-align:center">在元素被拖动时反复触发</td></tr><tr><td style="text-align:center"></td><td style="text-align:left">dragend</td><td style="text-align:center">在拖动操作完成时触发</td></tr><tr><td style="text-align:center"></td><td style="text-align:left"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">目的地对象</td><td style="text-align:left">dragenter</td><td style="text-align:center">当被拖动元素进入目的地元素所占据的屏幕空间时触发</td></tr><tr><td style="text-align:center"></td><td style="text-align:left">dragover</td><td style="text-align:center">当被拖动元素在目的地元素内时触发</td></tr><tr><td style="text-align:center"></td><td style="text-align:left">dragleave</td><td style="text-align:center">当被拖动元素没有放下就离开目的地元素时触发</td></tr></tbody></table><p>dragenter和dragover事件的默认行为是拒绝接受任何被拖放的元素。因此，我们必须阻止浏览器这种默认行为。e.preventDefault();</p><h3 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h3><p>到达目的地之后，释放元素事件</p><table><thead><tr><th style="text-align:center">针对对象</th><th style="text-align:left">事件名称</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">目的地对象</td><td style="text-align:left">drop</td><td style="text-align:center">当被拖动元素在目的地元素里放下时触发，一般需要取消浏览器的默认行为。</td></tr></tbody></table><h3 id="选中拖动释放例子"><a href="#选中拖动释放例子" class="headerlink" title="选中拖动释放例子"></a>选中拖动释放例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE HTML&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;拖放示例-文本&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">.src &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.dropabled &#123;</span><br><span class="line">    flex: 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.txt &#123;</span><br><span class="line">    color: green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.img &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    border: 1px solid gray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.target &#123;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 200px;</span><br><span class="line">    line-height: 200px;</span><br><span class="line">    text-align: center;</span><br><span class="line">    border: 1px solid gray;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;src&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;dragabled&quot;&gt;</span><br><span class="line">            &lt;div class=&quot;txt&quot; id=&quot;txt&quot;&gt;</span><br><span class="line">                所有的文字都可拖拽。</span><br><span class="line">                &lt;p draggable=&quot;true&quot;&gt;此段文字设置了属性draggable=&quot;true&quot;&lt;/p&gt;  </span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;div class=&quot;url&quot; id=&quot;url&quot;&gt;</span><br><span class="line">                &lt;a href=&quot;http://weiqinl.com&quot; target=&quot;_blank&quot;&gt;我是url:http://weiqinl.com&lt;/a&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;img class=&quot;img&quot; id=&quot;tupian1&quot; src=&quot;img1.png&quot; alt=&quot;图片1&quot; /&gt;</span><br><span class="line">            &lt;img class=&quot;img&quot; id=&quot;tupian2&quot; src=&quot;img2.png&quot; alt=&quot;图片2&quot; /&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div id=&apos;target&apos; class=&quot;dropabled target&quot;&gt;Drop Here&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        var dragSrc = document.getElementById(&apos;txt&apos;)</span><br><span class="line">        var target = document.getElementById(&apos;target&apos;)</span><br><span class="line"></span><br><span class="line">        dragSrc.ondragstart = handle_start</span><br><span class="line">        dragSrc.ondrag = handle_drag</span><br><span class="line">        dragSrc.ondragend = handle_end</span><br><span class="line"></span><br><span class="line">        function handle_start(e) &#123;</span><br><span class="line">          console.log(&apos;dragstart-在元素开始被拖动时候触发&apos;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      function handle_drag() &#123;</span><br><span class="line">            console.log(&apos;drag-在元素被拖动时候反复触发&apos;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      function handle_end() &#123;</span><br><span class="line">            console.log(&apos;dragend-在拖动操作完成时触发&apos;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        target.ondragenter = handle_enter</span><br><span class="line">        target.ondragover = handle_over</span><br><span class="line">        target.ondragleave = handle_leave</span><br><span class="line"></span><br><span class="line">        target.ondrop = handle_drop</span><br><span class="line"></span><br><span class="line">        function handle_enter(e) &#123;</span><br><span class="line">            console.log(&apos;handle_enter-当元素进入目的地时触发&apos;)</span><br><span class="line">            // 阻止浏览器默认行为</span><br><span class="line">            e.preventDefault()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        function handle_over(e) &#123;</span><br><span class="line">            console.log(&apos;handle_over-当元素在目的地时触发&apos;)</span><br><span class="line">            // 阻止浏览器默认行为</span><br><span class="line">            e.preventDefault()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        function handle_leave(e) &#123;</span><br><span class="line">            console.log(&apos;handle_leave-当元素离开目的地时触发&apos;)</span><br><span class="line">            // 阻止浏览器默认行为</span><br><span class="line">            // e.preventDefault()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        function handle_drop(e) &#123;</span><br><span class="line">            console.log(&apos;handle_drop-当元素在目的地放下时触发&apos;)</span><br><span class="line">            var t = Date.now()</span><br><span class="line">            target.innerHTML = &apos;&apos;</span><br><span class="line">            target.append(t + &apos;-拖放触发的事件。&apos;)</span><br><span class="line">            e.preventDefault()</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><a href="https://codepen.io/weiqinl/pen/XzRYOw" target="_blank" rel="noopener">drag-drop事件触发</a></p><p>在整个拖放过程中，我们以上说的是表面现象，事件过程内部还会发生什么事情呢？请看下面👇的DataTransfer对象。</p><h2 id="DataTransfer对象"><a href="#DataTransfer对象" class="headerlink" title="DataTransfer对象"></a>DataTransfer对象</h2><p>与拖放操作所触发的事件同时派发的对象是DragEvent，它派生于MouseEvent，具有Event与MouseEvent对象的所有功能，并增加了dataTransfer属性。该属性用于保存拖放的数据和交互信息，返回DataTransfer对象。<br>// DataTransfer dataTransfer = DragEvent.dataTransfer<br>DataTransfer对象定义的属性和方法有很多种，我们看下列入标准的几个。</p><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DataTransfer/types" target="_blank" rel="noopener">types</a></td><td style="text-align:left">只读属性。它返回一个我们在dragstart事件中设置的拖动数据格式的数组。 格式顺序与拖动操作中包含的数据顺序相同。IE10+、Edge、safari3.1、Firefox3.5+ 和Chrome4以上支持该属性</td></tr><tr><td style="text-align:left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DataTransfer/files" target="_blank" rel="noopener">files</a></td><td style="text-align:left">返回拖动操作中的文件列表。包含一个在数据传输上所有可用的本地文件列表。如果拖动操作不涉及拖动文件，此属性是一个空列表。</td></tr><tr><td style="text-align:left"><a href="https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer/dropEffect" target="_blank" rel="noopener">dropEffect</a></td><td style="text-align:left">获取当前选定的拖放操作的类型或将操作设置为新类型。它应该始终设置成effectAllowed的可能值之一【none、move、copy、link】。dragover事件处理程序中针对放置目标来设置dropEffect。</td></tr><tr><td style="text-align:left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DataTransfer/effectAllowed" target="_blank" rel="noopener">effectAllowed</a></td><td style="text-align:left">指定拖放操作所允许的效果。必须是其中之一【 none, copy, copyLink, copyMove, link, linkMove, move, all, uninitialized】默认为uninitialized 表示允许所有的效果。ondragstart处理程序中设置effectAllowed属性</td></tr></tbody></table><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer/setData" target="_blank" rel="noopener">void setData(format, data)</a></td><td style="text-align:left">将拖动操作的拖动数据设置为指定的数据和类型。format可以是MIME类型</td></tr><tr><td style="text-align:left"><a href="https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer/getData" target="_blank" rel="noopener">String getData(format)</a></td><td style="text-align:left">返回指定格式的数据，format与setData()中一致</td></tr><tr><td style="text-align:left"><a href="https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer/clearData" target="_blank" rel="noopener">void clearData([format])</a></td><td style="text-align:left">删除给定类型的拖动操作的数据。如果给定类型的数据不存在，此方法不执行任何操作。如果不给定参数，则删除所有类型的数据。</td></tr><tr><td style="text-align:left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DataTransfer/setDragImage" target="_blank" rel="noopener">void setDragImage(img, xOffset, yOffset)</a></td><td style="text-align:left">指定一副图像，当拖动发生时，显示在光标下方。大多数情况下不用设置，因为被拖动的节点被创建成默认图片。x,y参数分别指示图像的水平、垂直偏移量</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//IE10及之前版本，不支持扩展的MIME类型名</span><br><span class="line">//Firefox 5版本之前，不能正确的将url和text映射为text/uri-list 和text/plain</span><br><span class="line">var dataTransfer = event.dataTransfer;</span><br><span class="line">//读取文本，</span><br><span class="line">var text = dataTransfer.getData(&quot;Text&quot;);</span><br><span class="line">//读取URL,</span><br><span class="line">var url = dataTransfer.getData(&quot;url&quot;) || dataTransfer.getData(&quot;text/uri-list&quot;);</span><br></pre></td></tr></table></figure><p><a href="https://codepen.io/weiqinl/pen/aVEard" target="_blank" rel="noopener">drag-drop-dataTransfer各属性方法示例</a></p><h2 id="浏览器支持程度"><a href="#浏览器支持程度" class="headerlink" title="浏览器支持程度"></a>浏览器支持程度</h2><p>说了这么多，如果浏览器不支持，也是白扯。</p><p>Method of easily dragging and dropping elements on a page, requiring minimal JavaScript.<br>要求最少的js，实现拖拽页面元素的简单方法<br><img src="http://images2017.cnblogs.com/blog/564792/201711/564792-20171123172447852-1258046031.png" alt="Drag and Drop 浏览器兼容性.png"></p><p><a href="http://caniuse.com/#search=drag" target="_blank" rel="noopener">drag之浏览器支持程度–caniuse</a><br>￼<br><strong>note</strong></p><ul><li><code>dataTransfer.items</code> 只有Chrome支持</li><li><code>dropzone</code>属性，目前没有浏览器支持</li><li>Firefox支持<code>.setDragImage</code>任何类型的DOM元素。Chrome必须有<code>HTMLImageElement</code>或者任何DOM元素，该DOM元素附加到DOM 和浏览器的<code>.setDragImage</code>视口(viewport)内。<br>  1.部分支持是指不支持<code>dataTransfer.files</code> 或者 <code>.types</code>对象<br>  2.部分支持是指不支持<code>.setDragImage</code><br>  3.部分支持是指<code>dataTransfer.setData / getData</code> 的有限支持格式</li></ul><p>以下，我在实际中遇到的情况，各浏览器对标准的实现还是有差异的。</p><ul><li><code>getData()</code>在chrome 62.0浏览器中，只能在<code>drop</code>事件中生效。</li><li>如果使用<code>setDragImage</code>方法，指定的图像不存在，则拖动过程：<ol><li>safari 11.0.1 浏览器，只会触发<code>dragstart</code>和<code>dragend</code>事件。</li><li>chrome、opera 和 Firefox会正常触发其他事件。</li></ol></li><li>每一次拖放操作，Firefox都会执行一次新开一个页面的动作，并且自动搜索<code>dataTransfer.getData()</code>得到的内容。<br>解决方法，在<code>drop</code>事件中，添加： <code>e.stopPropagation();// 不再派发事件。解决Firefox浏览器，打开新窗口的问题</code>。</li><li>opera 49版本中，链接默认不可以拖动，必须把<code>draggable</code>属性设置为<code>true</code>，才可以拖动。</li><li>关于 <code>dropEffect</code> 和 <code>effectAllowed</code> 。<ol><li><code>effectAllowed</code> 允许拖放操作的效果，最多不会超过那么几种。<code>dropEffect</code> 设置拖放操作的具体效果，只能是四种可能之一。</li><li>如果<code>effectAllowed</code>设置为<code>none</code>，则不允许拖放元素。但是各个浏览器能触发的事件不一样。（注意：safari可以拖放元素，而且会触发所有事件）</li><li>如果<code>dropEffect</code>设置为<code>none</code>，则不允许被拖放到目的地元素中。</li><li>如果设置了<code>effectAllowed</code>的值，那么如果要设置<code>dropEffect</code>的值，其值必须和<code>effectAllowed</code>的值一致，否则拖动效果无效，而且不允许将被拖放元素放到目的地元素中。(注：safari11.0.1有效果，而且也能拖动到目的地元素中，但是这不符合标准)。</li></ol></li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><a href="https://codepen.io/weiqinl/pen/aVEard" target="_blank" rel="noopener">drag-drop-dataTransfer各属性方法示例</a><br><a href="https://codepen.io/weiqinl/pen/XzRYOw" target="_blank" rel="noopener">drag-drop事件触发</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>原生HTML5拖拽API，drag &amp;&amp; drop 在实际工作中，还是有很多情况下会遇到的。<br>以上，我只介绍了部分常用API。API不复杂，多看会儿，实践就知道了。各个浏览器，可能会在表现上，稍有不同，但我相信大家还是会向着标准发展的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;拖放（drap &amp;amp;&amp;amp; drop）在我们平时的工作中，经常遇到。它表示：抓取对象以后拖放到另一个位置。目前，它是HTML5标准的一部分。我从几个方面学习并实践这个功能。&lt;/p&gt;
&lt;h2 id=&quot;拖放的流程对应的事件&quot;&gt;&lt;a href=&quot;#拖放的流程对应的事件&quot; class=&quot;headerlink&quot; title=&quot;拖放的流程对应的事件&quot;&gt;&lt;/a&gt;拖放的流程对应的事件&lt;/h2&gt;&lt;p&gt;我们先看下拖放的流程：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;选中  ---&amp;gt;  拖动  ---&amp;gt; 释放&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;然后，我们一步步看下这个过程中，会发生的事情。&lt;/p&gt;
&lt;h3 id=&quot;选中&quot;&gt;&lt;a href=&quot;#选中&quot; class=&quot;headerlink&quot; title=&quot;选中&quot;&gt;&lt;/a&gt;选中&lt;/h3&gt;&lt;p&gt;在HTML5标准中，为了使元素可拖动，把draggable属性设置为true。&lt;br&gt;文本、图片和链接是默认可以拖放的，它们的draggable属性自动被设置成了true。&lt;br&gt;图片和链接按住鼠标左键选中，就可以拖放。&lt;br&gt;文本只有在被选中的情况下才能拖放。如果显示设置文本的draggable属性为true，按住鼠标左键也可以直接拖放。&lt;/p&gt;
&lt;p&gt;draggable属性：设置元素是否可拖动。&lt;br&gt;语法：&lt;code&gt;&amp;lt;element draggable=&amp;quot;true | false | auto&amp;quot; &amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;true: 可以拖动  &lt;/li&gt;
&lt;li&gt;false: 禁止拖动  &lt;/li&gt;
&lt;li&gt;auto: 跟随浏览器定义是否可以拖动  &lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="html" scheme="http://weiqinl.com/tags/html/"/>
    
      <category term="drag" scheme="http://weiqinl.com/tags/drag/"/>
    
      <category term="drop" scheme="http://weiqinl.com/tags/drop/"/>
    
  </entry>
  
  <entry>
    <title>关于网站切换主题色的一些思考与实现</title>
    <link href="http://weiqinl.com/2017/11/30/%E5%85%B3%E4%BA%8E%E7%BD%91%E7%AB%99%E5%88%87%E6%8D%A2%E4%B8%BB%E9%A2%98%E8%89%B2%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <id>http://weiqinl.com/2017/11/30/关于网站切换主题色的一些思考与实现/</id>
    <published>2017-11-30T09:00:23.000Z</published>
    <updated>2018-04-17T03:13:40.039Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>web应用程序，切换主题，给其换肤，是一个比较常见的需求。</p><ul><li>如何能快速的切换主题色？(只有固定的一种皮肤)</li><li>如果又想把主题色切换为以前的呢？（有多种可切换的皮肤）</li><li>该以何种方式编写标签的css属性？</li></ul><p>快速切换主题这个需求，它考验了项目的CSS代码，是否具有可维护性、可扩展性。<br>css要如何编写，才能达到这两点呢，我还在研究学习当中，可以参考<a href="http://www.zcfy.cc/article/structuring-css-in-large-projects-1202.html" target="_blank" rel="noopener">在大型项目中组织CSS</a>。<br>本来，此文想写这个的，发现道行不够(┬＿┬)，我还是写如何实现的，比较好。</p><p>想要换主色调，其实就是换一种风格样式，最终都是换css。<br>我看目前比较流行的几种切换主题的方式：</p><ul><li>所有样式的css模版都在项目中，根据条件，给body添加class，通过不同的class来显示不同的样式。</li><li>通过引用不同的link文件，达到效果。</li><li>ElementUI的这种方式，详情见<a href="https://github.com/ElemeFE/element/issues/3054" target="_blank" rel="noopener">ISSUE</a><br>（1） 先把默认主题文件中涉及到颜色的 CSS 值替换成关键词<br>（2） 根据用户选择的主题色生成一系列对应的颜色值<br>（3） 把关键词再换回刚刚生成的相应的颜色值<br>（4） 直接在页面上加 style 标签，把生成的样式填进去</li></ul><p>我目前用的是第一种方式，把操作过程记录下来，方便以后查看。<br><a id="more"></a></p><h2 id="如何增加主题文件-具体操作过程"><a href="#如何增加主题文件-具体操作过程" class="headerlink" title="如何增加主题文件-具体操作过程"></a>如何增加主题文件-具体操作过程</h2><p><img src="http://images2017.cnblogs.com/blog/564792/201710/564792-20171027190425523-1992772762.gif" alt="动态换肤.gif"></p><p>说明：<a href="https://github.com/weiqinl/vue-element-admin" target="_blank" rel="noopener">此项目UI</a>是在elementUI基础上建立的，所以，我们可以通过element提供的方法，来<a href="http://element.eleme.io/#/zh-CN/component/custom-theme" target="_blank" rel="noopener">自定义主题</a>。</p><h3 id="生成自定义主题文件"><a href="#生成自定义主题文件" class="headerlink" title="生成自定义主题文件"></a>生成自定义主题文件</h3><p>使用工具下载自定义主题文件，并命名为<code>wq-variables.css</code>。以后我们如果想要增加主题文件，只需要修改变量文件中各个变量所对应的值。</p><h3 id="编译主题"><a href="#编译主题" class="headerlink" title="编译主题"></a>编译主题</h3><p>我们利用<a href="http://element.eleme.io/#/zh-CN/component/custom-theme#an-zhuang-gong-ju" target="_blank" rel="noopener">工具</a>来编译主题。<br>在终端，将刚刚修改好的变量文件，通过命令<code>node_modules/.bin/et -c wq-variables.css</code>来编译主题。</p><h3 id="给自定义主题增加命名空间"><a href="#给自定义主题增加命名空间" class="headerlink" title="给自定义主题增加命名空间"></a>给自定义主题增加命名空间</h3><p>默认情况下，编译的主题目录会放在<code>./theme</code>下。由于，我们是通过改变css的命名空间来切换主题的，那么，我们就需要为刚生成的主题增加命名空间。主题文件内容很多，如果手动一个个添加命名空间，工作量巨大，这个时候，可以使用另一个<a href="https://github.com/weiqinl/tool-web/tree/master/gulpcsswrap" target="_blank" rel="noopener">给css增加命名空间的工具</a>。下载这个项目，然后只需要修改<code>gulpfile.js</code>文件中3处内容，就可以得到想要的内容，这里注意，本项目css自定义的命名空间统一为<code>custom-******</code>,其中<code>******</code>建议使用主题色的16进制编码,也可以使用其他字符串，但是要和radio标签统一。</p><h3 id="引用自定义主题"><a href="#引用自定义主题" class="headerlink" title="引用自定义主题"></a>引用自定义主题</h3><p>自定义主题文件，已经有了，只剩下如何引入使用了。</p><ul><li>在<code>App.vue</code>中import新增的主题样式（这个也可以写在topbar.vue文件中，到底哪种好些，我也不清楚）</li><li>在<code>./src/components/nav/topbar/topbar.vue</code>中，添加对应的radio标签<br>经过以上两步，就可以正常使用了。</li></ul><h3 id="如何处理与自定义主题不同部分的样式"><a href="#如何处理与自定义主题不同部分的样式" class="headerlink" title="如何处理与自定义主题不同部分的样式"></a>如何处理与自定义主题不同部分的样式</h3><p>可以新建一个css文件，然后在其中编写样式，之后在入口文件引入就ok了。</p><p>具体效果，可查看于此网站：<br><a href="http://weiqinl.com/vue-element-admin/">http://weiqinl.com/vue-element-admin/</a></p><p>此做法参考于：<br><a href="https://segmentfault.com/a/1190000009762198#articleHeader2" target="_blank" rel="noopener">基于Element的动态换肤</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;web应用程序，切换主题，给其换肤，是一个比较常见的需求。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何能快速的切换主题色？(只有固定的一种皮肤)&lt;/li&gt;
&lt;li&gt;如果又想把主题色切换为以前的呢？（有多种可切换的皮肤）&lt;/li&gt;
&lt;li&gt;该以何种方式编写标签的css属性？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;快速切换主题这个需求，它考验了项目的CSS代码，是否具有可维护性、可扩展性。&lt;br&gt;css要如何编写，才能达到这两点呢，我还在研究学习当中，可以参考&lt;a href=&quot;http://www.zcfy.cc/article/structuring-css-in-large-projects-1202.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;在大型项目中组织CSS&lt;/a&gt;。&lt;br&gt;本来，此文想写这个的，发现道行不够(┬＿┬)，我还是写如何实现的，比较好。&lt;/p&gt;
&lt;p&gt;想要换主色调，其实就是换一种风格样式，最终都是换css。&lt;br&gt;我看目前比较流行的几种切换主题的方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有样式的css模版都在项目中，根据条件，给body添加class，通过不同的class来显示不同的样式。&lt;/li&gt;
&lt;li&gt;通过引用不同的link文件，达到效果。&lt;/li&gt;
&lt;li&gt;ElementUI的这种方式，详情见&lt;a href=&quot;https://github.com/ElemeFE/element/issues/3054&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ISSUE&lt;/a&gt;&lt;br&gt;（1） 先把默认主题文件中涉及到颜色的 CSS 值替换成关键词&lt;br&gt;（2） 根据用户选择的主题色生成一系列对应的颜色值&lt;br&gt;（3） 把关键词再换回刚刚生成的相应的颜色值&lt;br&gt;（4） 直接在页面上加 style 标签，把生成的样式填进去&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我目前用的是第一种方式，把操作过程记录下来，方便以后查看。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="css" scheme="http://weiqinl.com/tags/css/"/>
    
      <category term="网站" scheme="http://weiqinl.com/tags/%E7%BD%91%E7%AB%99/"/>
    
      <category term="换主题" scheme="http://weiqinl.com/tags/%E6%8D%A2%E4%B8%BB%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Windows上安装nodejs版本管理器nvm</title>
    <link href="http://weiqinl.com/2017/09/21/Windows%E4%B8%8A%E5%AE%89%E8%A3%85nodejs%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%99%A8nvm/"/>
    <id>http://weiqinl.com/2017/09/21/Windows上安装nodejs版本管理器nvm/</id>
    <published>2017-09-21T04:34:08.000Z</published>
    <updated>2018-04-17T03:13:40.035Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/coreybutler/nvm-windows/releases" target="_blank" rel="noopener">nvm最新的下载地址</a></p><p>Node版本管理器–nvm，可以运行在多种操作系统上。nvm for windows 是使用go语言编写的软件。 我电脑使用的是Windows操作系统，所以我要记录下在此操作系统上nvm的安装和使用。</p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>nvm-windows 最新下载地址：<br><a href="https://github.com/coreybutler/nvm-windows/releases" target="_blank" rel="noopener">https://github.com/coreybutler/nvm-windows/releases</a><br><a id="more"></a><br>如图所示：<br><img src="http://upload-images.jianshu.io/upload_images/1808701-564dd30e0bc57f4f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图1：nvm-windows版本.png"></p><p>我目前看到有两个版本【Pre-release 1.1.6】和 【Latest release 1.1.5]，我们下载目前稳定版本1.1.5就可以了。1.1.6版本是最新版本，可能还不是很稳定。<br>而这里又有四个可下载的文件。</p><ul><li>nvm-noinstall.zip：  这个是绿色免安装版本，但是使用之前需要配置</li><li>nvm-setup.zip：这是一个安装包，下载之后点击安装，无需配置就可以使用，方便。</li><li>Source code(zip)：zip压缩的源码</li><li>Sourc code(tar.gz)：tar.gz的源码，一般用于*nix系统</li></ul><p>我对这个目前只是简单使用，为了方便，所以下载了nvm-set.zip文件。</p><h2 id="安装和升级"><a href="#安装和升级" class="headerlink" title="安装和升级"></a>安装和升级</h2><h3 id="安装之前的操作"><a href="#安装之前的操作" class="headerlink" title="安装之前的操作"></a>安装之前的操作</h3><p><strong>请注意</strong>： 在安装nvm for windows之前，你需要卸载任何现有版本的node.js。并且需要删除现有的nodejs安装目录（例如：”C:\Program Files\nodejs’）。因为，nvm生成的symlink（符号链接/超链接)不会覆盖现有的（甚至是空的）安装目录。<br>你还需要删除现有的npm安装位置（例如“C:\Users\weiqinl\AppData\Roaming\npm”），以便正确使用nvm安装位置。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>以上操作完成之后，双击执行下载的setup文件，<br><img src="http://upload-images.jianshu.io/upload_images/1808701-d480949cf800d01f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图2：双击之后的界面"><br>Next之后，选择同意协议，之后选择nvm的本地安装目录，<strong>这里注意，nvm的安装路径名称中最好不要有空格。</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/1808701-51dd258e9443333f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图3：nvm的安装目录"><br>例如最好不要这样有空格的<code>~\Program Files\nvm</code>，我这里选择的是<code>D:\softtool\nvm</code>。<br>点击Next，跳转到设置 Node.js的Symlink，即需要设置nodejs的快捷方式存放的目录。<br><img src="http://upload-images.jianshu.io/upload_images/1808701-52091d6cc4fbdcac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图4：nodejs安装的目录"><br>之后，点击Next–&gt;Install–&gt;Finish完成本次安装。</p><h3 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h3><p>检查是否安装成功，我们可以在新的命令窗口中输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm</span><br></pre></td></tr></table></figure></p><ul><li>如果出现nvm版本号和一系列帮助指令，则说明nvm安装成功。</li><li>否则，可能会提示<code>nvm: command not found</code></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1808701-674e35ac056aa068.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图5：nvm安装成功检测"></p><h3 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h3><p>如果要升级的话，请重新<a href="https://github.com/coreybutler/nvm-windows/releases" target="_blank" rel="noopener">下载最新的安装程序</a>。并直接运行安装程序。它将安全的覆盖需要更新的文件，而无需关心nodejs的安装。<br>此次安装需要确保和上次使用相同的安装目录。<br>如果你最初安装到默认位置，则只需一直点击”下一步”，直到完成。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>nvm for windows是一个命令行工具，在控制台输入<code>nvm</code>,就可以看到它的命令用法。基本命令有：</p><ul><li><code>nvm arch [32|64]</code> ： 显示node是运行在32位还是64位模式。指定32或64来覆盖默认体系结构。</li><li><code>nvm install &lt;version&gt; [arch]</code>： 该<version>可以是node.js版本或最新稳定版本<code>latest</code>。（可选[arch]）指定安装32位或64位版本（默认为系统arch）。设置[arch]为<code>all</code>以安装32和64位版本。在命令后面添加<code>--insecure</code> ，可以绕过远端下载服务器的SSL验证。</version></li><li><code>nvm list [available]</code>： 列出已经安装的node.js版本。可选的available，显示可下载版本的部分列表。这个命令可以简写为<code>nvm ls [available]</code>。</li><li><code>nvm on</code>： 启用node.js版本管理。</li><li><code>nvm off</code>： 禁用node.js版本管理(不卸载任何东西)</li><li><code>nvm proxy [url]</code>： 设置用于下载的代理。留<code>[url]</code>空白，以查看当前的代理。设置<code>[url]</code>为<code>none</code>删除代理。</li><li><code>nvm node_mirror [url]</code>：设置node镜像，默认为<code>https://nodejs.org/dist/.</code>。我建议设置为淘宝的镜像<em><a href="https://npm.taobao.org/mirrors/node/" target="_blank" rel="noopener">https://npm.taobao.org/mirrors/node/</a></em></li><li><code>nvm npm_mirror [url]</code>：设置npm镜像，默认为<code>https://github.com/npm/npm/archive/</code>。我建议设置为淘宝的镜像<em><a href="https://npm.taobao.org/mirrors/npm/" target="_blank" rel="noopener">https://npm.taobao.org/mirrors/npm/</a></em></li><li><code>nvm uninstall &lt;version&gt;</code>： 卸载指定版本的nodejs。</li><li><code>nvm use [version] [arch]</code>： 切换到使用指定的nodejs版本。可以指定32/64位[arch]。<code>nvm use &lt;arch&gt;</code>将继续使用所选版本，但根据提供的值切换到32/64位模式的<code>&lt;arch&gt;</code></li><li><code>nvm root [path]</code>： 设置  nvm 存储node.js不同版本的目录 ,如果<path></path>未设置，将使用当前目录。</li><li><code>nvm version</code>： 显示当前运行的nvm版本，可以简写为<code>nvm v</code></li></ul><p>一个nodejs的安装使用流程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nvm ls   // 查看目前已经安装的版本</span><br><span class="line">nvm install 6.10.0  // 安装指定的版本的nodejs</span><br><span class="line">nvm use 6.10.0  // 使用指定版本的nodejs</span><br></pre></td></tr></table></figure></p><p>这是我安装第一个版本时候的命令:</p><p><img src="http://upload-images.jianshu.io/upload_images/1808701-34e4937c0476edff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图6：这是我安装第一个版本时候的命令"></p><p>认真看以下的图，相同的<code>nvm ls</code>命令，得到的结果为什么不一样？因为，这是使用了nvm切换到了指定的版本。如果在<code>nvm ls</code>命令输出了 当前样式，说明切换成功了。如果没有出现<code>(Currently using 64-bit executable)</code>，则表示没有切换成功。这就需要查看原因，认真按照上面步骤来。<br><img src="http://upload-images.jianshu.io/upload_images/1808701-17170456e4595ab5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图7：nvm ls展示已经安装的nodejs版本"></p><h3 id="使用命令时注意点"><a href="#使用命令时注意点" class="headerlink" title="使用命令时注意点"></a>使用命令时注意点</h3><ul><li>请用管理员身份运行命令管理器，否则可能出错。</li><li>先设置<a href="https://npm.taobao.org/mirrors/node/" target="_blank" rel="noopener">node</a>和<a href="https://npm.taobao.org/mirrors/npm/" target="_blank" rel="noopener">npm</a>的淘宝镜像，这样成功率和下载速度会更高点。</li></ul><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>1：主要用途，切换nodejs版本。如果想使用最新的流行版本测试您正在开发的模块，而不用卸载稳定版本的node，则可以使用nvm来切换nodejs版本。</p><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><ul><li>nvm安装目录，最好不要存在空格。否则，nvm可以安装成功，但使用nvm use x.y.z（nodejs的切换）会有问题。</li><li>有些全局的npm模块，可能在各版本的node.js之间不共享。<br>你正在使用的node.js版本中可能不支持某些npm模块。因此在工作的时候请注意工作环境。</li></ul><p>博客园地址：</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/coreybutler/nvm-windows/releases&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;nvm最新的下载地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Node版本管理器–nvm，可以运行在多种操作系统上。nvm for windows 是使用go语言编写的软件。 我电脑使用的是Windows操作系统，所以我要记录下在此操作系统上nvm的安装和使用。&lt;/p&gt;
&lt;h2 id=&quot;下载&quot;&gt;&lt;a href=&quot;#下载&quot; class=&quot;headerlink&quot; title=&quot;下载&quot;&gt;&lt;/a&gt;下载&lt;/h2&gt;&lt;p&gt;nvm-windows 最新下载地址：&lt;br&gt;&lt;a href=&quot;https://github.com/coreybutler/nvm-windows/releases&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/coreybutler/nvm-windows/releases&lt;/a&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="nvm" scheme="http://weiqinl.com/tags/nvm/"/>
    
      <category term="nodejs" scheme="http://weiqinl.com/tags/nodejs/"/>
    
      <category term="windows" scheme="http://weiqinl.com/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>CSS3 box-sizing属性的应用</title>
    <link href="http://weiqinl.com/2017/09/21/CSS3-box-sizing%E5%B1%9E%E6%80%A7%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>http://weiqinl.com/2017/09/21/CSS3-box-sizing属性的应用/</id>
    <published>2017-09-21T04:26:48.000Z</published>
    <updated>2018-04-17T03:13:40.032Z</updated>
    
    <content type="html"><![CDATA[<p>在一个文档中，每个元素都被表示为一个矩形的盒子。盒子模型具有4个属性[‘外边距(margin)’,’边框(border)’,’内边距(padding)’,’内容(content)’]。<br>我们要设置某个元素的大小定位，肯定会和这四个元素打交道。只是元素的宽高计算有些默认值。<br><strong>box-sizing</strong>属性用于更改用于计算元素宽度和高度的默认的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Box_Model/Introduction_to_the_CSS_box_model" target="_blank" rel="noopener">CSS 盒子模型</a>。可以使用此属性来模拟不正确支持CSS盒子模型规范的浏览器的行为。<br>目前支持box-sizing的浏览器：<br><img src="http://upload-images.jianshu.io/upload_images/1808701-e590a5511a91727a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="支持box-sizing的浏览器"><br>就目前来看，大部分人是建议在初始化样式的时候，就设置为<code>border-box</code>，这样更方便设置元素的宽高<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">  -webkit-box-sizing: border-box;</span><br><span class="line">     -moz-box-sizing: border-box;</span><br><span class="line">          box-sizing: border-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">box-sizing: content-box | border-box | inherit;</span><br></pre></td></tr></table></figure><h3 id="值"><a href="#值" class="headerlink" title="值"></a>值</h3><p><strong>content-box</strong><br>   默认值，标准盒子模型。<code>width</code> 和 <code>height</code> 只包括内容(<code>content</code>)的宽和高。在宽度和高度之外绘制元素的内边距和边框。  </p><p>尺寸计算公式:</p><font color="red">width = 内容的宽度。<br>height = 内容的高度。</font>  <p><strong>border-box</strong><br><code>width</code>和<code>height</code>属性包括内容(<code>content</code>)、内边距(<code>padding</code>)、边框(<code>border</code>)，但是不包括外边距(<code>margin</code>)。在宽度和高度之内绘制元素的内容、内边距和边框。</p><p>尺寸计算公式： </p><font color="red">width = 内容的宽度 + 内边距的宽度 + 边框的宽度。<br>height = 内容的高度 + 内边距的高度 + 边框的高度。</font>  <p><strong>inherit</strong><br> 规定应该从父元素继承 <code>box-sizing</code> 属性的值</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p><a href="https://codepen.io/weiqinl/pen/qPNRgK" target="_blank" rel="noopener">在线例子</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;box-sizing的使用&lt;/title&gt;</span><br><span class="line">  &lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">  .box &#123;</span><br><span class="line">    width: 460px;</span><br><span class="line">    height: 400px;</span><br><span class="line">    border: 1px solid red;</span><br><span class="line">    margin: 10px;</span><br><span class="line">    background-color: gray;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .content &#123;</span><br><span class="line">    box-sizing: content-box;</span><br><span class="line">    border: 10px solid blue;</span><br><span class="line">    width: 300px;</span><br><span class="line">    padding: 20px;</span><br><span class="line">    margin: 30px;</span><br><span class="line">    background-color: green;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .border &#123;</span><br><span class="line">    box-sizing: border-box;</span><br><span class="line">    border: 10px solid blue;</span><br><span class="line">    width: 300px;</span><br><span class="line">    padding: 20px;</span><br><span class="line">    margin: 30px;</span><br><span class="line">    background-color: yellow;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .inherit &#123;</span><br><span class="line">    box-sizing: inherit;</span><br><span class="line">    border: 10px solid red;</span><br><span class="line">    width: 300px;</span><br><span class="line">    padding: 20px;</span><br><span class="line">    margin: 30px;</span><br><span class="line">    background-color: red;</span><br><span class="line">  &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div class=&quot;box&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;content&quot;&gt;</span><br><span class="line">      我是content-box值(默认)</span><br><span class="line">      &lt;br/&gt;box-sizing: content-box;</span><br><span class="line">      &lt;br/&gt;border: 10px solid blue;</span><br><span class="line">      &lt;br/&gt;width: 300px;</span><br><span class="line">      &lt;br/&gt;padding: 20px;</span><br><span class="line">      &lt;br/&gt; margin: 30px;</span><br><span class="line">      &lt;div class=&quot;inherit&quot;&gt;我是inherit值&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;box&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;border&quot;&gt;</span><br><span class="line">      我是border-box值</span><br><span class="line">      &lt;br/&gt;box-sizing: border-box;</span><br><span class="line">      &lt;br/&gt;border: 10px solid blue;</span><br><span class="line">      &lt;br/&gt;width: 300px;</span><br><span class="line">      &lt;br/&gt;padding: 20px;</span><br><span class="line">      &lt;br/&gt;margin: 30px;</span><br><span class="line">      &lt;div class=&quot;inherit&quot;&gt;我是inherit值&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>chrome截图：</p><p><img src="http://upload-images.jianshu.io/upload_images/1808701-1187d8721cb515c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="box-sizing的使用案例"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在一个文档中，每个元素都被表示为一个矩形的盒子。盒子模型具有4个属性[‘外边距(margin)’,’边框(border)’,’内边距(padding)’,’内容(content)’]。&lt;br&gt;我们要设置某个元素的大小定位，肯定会和这四个元素打交道。只是元素的宽高计算有些默认值。&lt;br&gt;&lt;strong&gt;box-sizing&lt;/strong&gt;属性用于更改用于计算元素宽度和高度的默认的 &lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Box_Model/Introduction_to_the_CSS_box_model&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CSS 盒子模型&lt;/a&gt;。可以使用此属性来模拟不正确支持CSS盒子模型规范的浏览器的行为。&lt;br&gt;目前支持box-sizing的浏览器：&lt;br&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1808701-e590a5511a91727a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;支持box-sizing的浏览器&quot;&gt;&lt;br&gt;就目前来看，大部分人是建议在初始化样式的时候，就设置为&lt;code&gt;border-box&lt;/code&gt;，这样更方便设置元素的宽高&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;* &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  -webkit-box-sizing: border-box;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     -moz-box-sizing: border-box;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          box-sizing: border-box;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="css" scheme="http://weiqinl.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>vue-cli生成的webpack配置解析-build/dev-server.js</title>
    <link href="http://weiqinl.com/2017/08/18/vue-cli%E7%94%9F%E6%88%90%E7%9A%84webpack%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90-build-dev-server-js/"/>
    <id>http://weiqinl.com/2017/08/18/vue-cli生成的webpack配置解析-build-dev-server-js/</id>
    <published>2017-08-18T11:15:36.000Z</published>
    <updated>2018-04-17T03:13:40.038Z</updated>
    
    <content type="html"><![CDATA[<p>#vue-cli生成的webpack配置解析-build/dev-server.js</p><p>我们在使用vue-cli搭建vuejs项目(<a href="http://www.cnblogs.com/weiqinl/p/6875645.html" target="_blank" rel="noopener">Vuejs实例-01使用vue-cli脚手架搭建Vue.js项目</a>)的时候，会自动生成一系列文件，其中就包含webpack配置文件。我们现在来看下，这些配置到底是什么意思，对我们开发过程中有什么影响。</p><p>项目搭建好了， 使用Bash运行<code>npm run dev</code>， 然后Bash界面会打印出一些东西，之后默认浏览器就打开了一个页面。为什么会有这些动作呢？我们从<code>package.json</code>开始看。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// package.json</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;dev&quot;: &quot;node build/dev-server.js&quot;,</span><br><span class="line">    &quot;start&quot;: &quot;node build/dev-server.js&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;node build/build.js&quot;,</span><br><span class="line">    &quot;unit&quot;: &quot;cross-env BABEL_ENV=test karma start test/unit/karma.conf.js --single-run&quot;,</span><br><span class="line">    &quot;e2e&quot;: &quot;node test/e2e/runner.js&quot;,</span><br><span class="line">    &quot;test&quot;: &quot;npm run unit &amp;&amp; npm run e2e&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行<code>npm run dev</code>其实是执行了 <code>build/dev-server.js</code>文件。<br>那我们现在先分析这个文件，直接上源码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line">// dev-server.js</span><br><span class="line">// 调用check-versions.js 模块，检查版本node和npm的版本</span><br><span class="line">require(&apos;./check-versions&apos;)()</span><br><span class="line"></span><br><span class="line">// 获取配置</span><br><span class="line">var config = require(&apos;../config&apos;)</span><br><span class="line">// 如果Node的环境变量中没有设置当前的环境(NODE_ENV), 则使用config中配置的环境作为当前环境</span><br><span class="line">if (!process.env.NODE_ENV) &#123;</span><br><span class="line">  process.env.NODE_ENV = JSON.parse(config.dev.env.NODE_ENV)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// opn模块，使用默认应用程序，打开网址、文件、 可执行程序等内容的一个插件。</span><br><span class="line">// 例如,使用默认浏览器打开urls。跨平台可用。</span><br><span class="line">// 这里用它来调用默认浏览器打开dev-server监听的端口，例如: localhost:8080</span><br><span class="line">var opn = require(&apos;opn&apos;)</span><br><span class="line">// path模块提供用于处理文件和目录路径的实用程序。</span><br><span class="line">var path = require(&apos;path&apos;)</span><br><span class="line">// 引入express 模块</span><br><span class="line">var express = require(&apos;express&apos;)</span><br><span class="line">// 引入 webpack模块</span><br><span class="line">var webpack = require(&apos;webpack&apos;)</span><br><span class="line"></span><br><span class="line">// 一个express中间件，用于将http请求代理到其他服务器</span><br><span class="line">// 例：localhost:8080/api/xxx  --&gt;  localhost:3000/api/xxx</span><br><span class="line">// 这里使用该插件可以将前端开发中涉及到的请求代理到API服务器上，方便与服务器对接</span><br><span class="line">var proxyMiddleware = require(&apos;http-proxy-middleware&apos;)</span><br><span class="line"></span><br><span class="line">// 根据 Node 环境来引入相应的 webpack 配置</span><br><span class="line">// 这里用 &quot;testing&quot; 来判断Node环境, 是因为在两个webpack.***.conf中还会有判断</span><br><span class="line">var webpackConfig = process.env.NODE_ENV === &apos;testing&apos;</span><br><span class="line">  ? require(&apos;./webpack.prod.conf&apos;)</span><br><span class="line">  : require(&apos;./webpack.dev.conf&apos;)</span><br><span class="line"></span><br><span class="line">// dev-server 监听的端口，默认为config.dev.port设置的端口，即8080</span><br><span class="line">// default port where dev server listens for incoming traffic</span><br><span class="line">var port = process.env.PORT || config.dev.port</span><br><span class="line"></span><br><span class="line">// 用于判断是否要自动打开浏览器的布尔变量，</span><br><span class="line">// 当配置文件中没有设置自动打开浏览器的时候其值为 false</span><br><span class="line">// `!!`是一个逻辑操作，表示强制转换类型。这里强制转换为`bool`类型</span><br><span class="line">// automatically open browser, if not set will be false</span><br><span class="line">var autoOpenBrowser = !!config.dev.autoOpenBrowser</span><br><span class="line"></span><br><span class="line">// 定义HTTP代理，到自定义API接口</span><br><span class="line">// Define HTTP proxies to your custom API backend</span><br><span class="line">// https://github.com/chimurai/http-proxy-middleware</span><br><span class="line">var proxyTable = config.dev.proxyTable</span><br><span class="line"></span><br><span class="line">// 创建一个express实例</span><br><span class="line">var app = express()</span><br><span class="line"></span><br><span class="line">// 根据webpack配置文件创建Compiler对象</span><br><span class="line">var compiler = webpack(webpackConfig)</span><br><span class="line"></span><br><span class="line">// 引入webpack开发中间件, 此插件只在开发环境中有用。</span><br><span class="line">// 使用compiler对象来对相应的文件进行编译和绑定</span><br><span class="line">// 编译绑定后将得到的产物存放在内存中而没有写进磁盘</span><br><span class="line">// 将这个中间件交给express使用之后即可访问这些编译后的产品文件</span><br><span class="line">var devMiddleware = require(&apos;webpack-dev-middleware&apos;)(compiler, &#123;</span><br><span class="line">  //绑定中间件到publicpath中，使用方法和在webpack中相同</span><br><span class="line">  publicPath: webpackConfig.output.publicPath, </span><br><span class="line">  quiet: true // 允许在console控制台显示 警告 和 错误 信息</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 引入热重载功能的中间件。</span><br><span class="line">// Webpack热重载仅使用webpack-dev-middleware开发中间件。</span><br><span class="line">// 这个中间件，允许您在没有webpack-dev-server的情况下，将热重载功能到现有服务器中。</span><br><span class="line">var hotMiddleware = require(&apos;webpack-hot-middleware&apos;)(compiler, &#123;</span><br><span class="line">  // 用于打印行的功能</span><br><span class="line">  log: () =&gt; &#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 当html-webpack-plugin 提交之后通过热重载中间件发布重载动作使得页面重载</span><br><span class="line">// force page reload when html-webpack-plugin template changes</span><br><span class="line">compiler.plugin(&apos;compilation&apos;, function (compilation) &#123;</span><br><span class="line">  compilation.plugin(&apos;html-webpack-plugin-after-emit&apos;, function (data, cb) &#123;</span><br><span class="line">    hotMiddleware.publish(&#123; action: &apos;reload&apos; &#125;)</span><br><span class="line">    cb()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 将 proxyTable 中的代理请求配置挂在express服务器上</span><br><span class="line">// proxy api requests</span><br><span class="line">Object.keys(proxyTable).forEach(function (context) &#123;</span><br><span class="line">  var options = proxyTable[context]</span><br><span class="line">  if (typeof options === &apos;string&apos;) &#123;</span><br><span class="line">    options = &#123; target: options &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  app.use(proxyMiddleware(options.filter || context, options))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// connect-history-api-fallback 模块，通过指定的索引页来代理请求的中间件，对于使用HTML5历史API的单个页面应用程序非常有用。</span><br><span class="line">// 处理 HTML5历史api回退的问题</span><br><span class="line">// handle fallback for HTML5 history API</span><br><span class="line">app.use(require(&apos;connect-history-api-fallback&apos;)())</span><br><span class="line"></span><br><span class="line">// 为webpack打包输出服务</span><br><span class="line">// serve webpack bundle output</span><br><span class="line">app.use(devMiddleware)</span><br><span class="line"></span><br><span class="line">// 热重载和状态保留功能</span><br><span class="line">// 显示编译错误信息</span><br><span class="line">// enable hot-reload and state-preserving</span><br><span class="line">// compilation error display</span><br><span class="line">app.use(hotMiddleware)</span><br><span class="line"></span><br><span class="line">// posix属性提供了对路径方法的POSIX特定实现的访问。</span><br><span class="line">// 服务纯静态资源。 利用Express托管静态文件，使其可以作为资源访问</span><br><span class="line">// 想要访问static文件夹下的资源，必须添加 staticPath 返回的地址作为上一级地址。</span><br><span class="line">// serve pure static assets</span><br><span class="line">var staticPath = path.posix.join(config.dev.assetsPublicPath, config.dev.assetsSubDirectory)</span><br><span class="line">app.use(staticPath, express.static(&apos;./static&apos;))</span><br><span class="line"></span><br><span class="line">// 应用启动时候的访问地址信息，例如 http://localhost:8080</span><br><span class="line">var uri = &apos;http://localhost:&apos; + port</span><br><span class="line"></span><br><span class="line">// 异步回调</span><br><span class="line">var _resolve</span><br><span class="line">var readyPromise = new Promise(resolve =&gt; &#123;</span><br><span class="line">  _resolve = resolve</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(&apos;&gt; Starting dev server...&apos;)</span><br><span class="line">// 如果webpack开发中间件有效执行，那么执行后面的回调函数。</span><br><span class="line">devMiddleware.waitUntilValid(() =&gt; &#123;</span><br><span class="line">  console.log(&apos;&gt; Listening at &apos; + uri + &apos;\n&apos;)</span><br><span class="line">  // 如果是 testing 环境， 不需要打开浏览器</span><br><span class="line">  // when env is testing, don&apos;t need open it</span><br><span class="line">  if (autoOpenBrowser &amp;&amp; process.env.NODE_ENV !== &apos;testing&apos;) &#123;</span><br><span class="line">    opn(uri)</span><br><span class="line">  &#125;</span><br><span class="line">  _resolve()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 启动express服务器并监听相应的端口（8080）</span><br><span class="line">var server = app.listen(port)</span><br><span class="line"></span><br><span class="line">// 模块导出。</span><br><span class="line">// 1：执行异步函数</span><br><span class="line">// 2：提供close方法，关闭服务器</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  ready: readyPromise,</span><br><span class="line">  close: () =&gt; &#123;</span><br><span class="line">    server.close()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上，就是我对这个文件的解析。</p><p>后续再对其他文件解析…欢迎关注😄</p><p>参考链接：<br><a href="http://blog.csdn.net/hongchh/article/details/55113751" target="_blank" rel="noopener">http://blog.csdn.net/hongchh/article/details/55113751</a></p><p>更多内容请查看:<br><a href="http://weiqinl.com">个人主页</a><br><a href="http://www.cnblogs.com/weiqinl" target="_blank" rel="noopener">博客园</a><br><a href="https://github.com/weiqinl" target="_blank" rel="noopener">github</a><br><a href="http://www.jianshu.com/u/9f890c7bde33" target="_blank" rel="noopener">简书</a><br>您的支持是对博主最大的鼓励，感谢您的认真阅读，欢迎留言讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;#vue-cli生成的webpack配置解析-build/dev-server.js&lt;/p&gt;
&lt;p&gt;我们在使用vue-cli搭建vuejs项目(&lt;a href=&quot;http://www.cnblogs.com/weiqinl/p/6875645.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Vuejs实例-01使用vue-cli脚手架搭建Vue.js项目&lt;/a&gt;)的时候，会自动生成一系列文件，其中就包含webpack配置文件。我们现在来看下，这些配置到底是什么意思，对我们开发过程中有什么影响。&lt;/p&gt;
&lt;p&gt;项目搭建好了， 使用Bash运行&lt;code&gt;npm run dev&lt;/code&gt;， 然后Bash界面会打印出一些东西，之后默认浏览器就打开了一个页面。为什么会有这些动作呢？我们从&lt;code&gt;package.json&lt;/code&gt;开始看。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="vue-cli" scheme="http://weiqinl.com/tags/vue-cli/"/>
    
      <category term="vuejs" scheme="http://weiqinl.com/tags/vuejs/"/>
    
      <category term="webpack" scheme="http://weiqinl.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>webpack的四个核心概念介绍</title>
    <link href="http://weiqinl.com/2017/08/17/webpack%E7%9A%84%E5%9B%9B%E4%B8%AA%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D/"/>
    <id>http://weiqinl.com/2017/08/17/webpack的四个核心概念介绍/</id>
    <published>2017-08-17T10:18:18.000Z</published>
    <updated>2018-04-17T03:13:40.039Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>webpack</code> 是一个当下最流行的前端资源的模块打包器。当 <code>webpack</code> 处理应用程序时，它会递归地构建一个依赖关系图(<code>dependency graph</code>)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成少量的<code>bundle</code> - 通常只有一个，由浏览器加载。<br><a id="more"></a></p><p><img src="http://images2017.cnblogs.com/blog/564792/201708/564792-20170817175752928-966850760.png" alt="webpack.png"></p><p>它是高度可配置的，我们先理解四个核心概念：入口(<code>entry</code>)、输出(<code>output</code>)、loader、插件(<code>plugins</code>)</p><h2 id="入口-entry"><a href="#入口-entry" class="headerlink" title="入口(entry)"></a>入口(entry)</h2><p>webpack 创建应用程序所有依赖的关系图。图的起点被称之为入口起点(<code>entry point</code>)。入口起点告诉 webpack 从哪里开始，并根据依赖关系图确定需要打包的内容。可以将应用程序的入口起点认为是根上下文或 APP第一个启动文件。</p><p>简单规则：每个 HTML 页面都有一个入口起点。单页应用(SPA)：一个入口起点，多页应用(MPA)：多个入口起点。</p><h3 id="简单语法"><a href="#简单语法" class="headerlink" title="简单语法"></a>简单语法</h3><p>用法：<code>entry: string | Arrary&lt;string&gt;</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//webpack.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry:  &apos;./src/index.js&apos;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><code>entry</code>属性的单个入口语法，在扩展配置的时候有失灵活性。它是下面的简写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//webpack.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: &apos;./src/index.js&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>向<code>entry</code>传入一个数组时候，将创建”多个主入口(multi-main entry)”。在你想要多个依赖文件一起注入，并且将他们的依赖导向(graph)到一个”chunk”时候，传入数组的方式就很有用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//webpack.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry:  [</span><br><span class="line">    &apos;./src/index.js&apos;,</span><br><span class="line">    &apos;babel-polyfill&apos;,</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="对象语法"><a href="#对象语法" class="headerlink" title="对象语法"></a>对象语法</h3><p>用法: <code>entry: {[entryChunkName: string]: string|Array&lt;string&gt;}</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//webpack.config.js</span><br><span class="line">module.export = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: &apos;./src/app.js&apos;,</span><br><span class="line">    vendors:  &apos;./src/vendors.js&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>对象语法会比较繁琐。然而，这是应用程序中定义入口的最可扩展的方式。</p><p> 这个配置告诉我们 webpack 从 <code>app.js</code> 和 <code>vendors.js</code> 开始创建依赖图。这些依赖图是彼此完全分离、互相独立的。这种方式比较常见于，只有一个入口起点（不包括 <code>vendor</code>，<code>vendor</code>一般都是动态加载的第三方模块。动态加载的模块不是入口起点。）的单页应用程序(single page application)中。不过，为了支持提供更佳 <code>vendor</code> 分离能力的 <code>DllPlugin</code>。 官方现在不太建议将第三方模块放到<code>entry.vendors</code>中。  </p><p>对象语法，更常见的应该是多入口应用程序-多页应用(MPA)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//webpack.config.js</span><br><span class="line">module.export = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    home: &quot;./home.js&quot;,</span><br><span class="line">    about: &quot;./about.js&quot;,</span><br><span class="line">    contact: &quot;./contact.js&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>此配置，告诉 webpack，我们 需要 3 个独立分离的依赖关系图.<br>在多页应用中，每当页面跳转时，服务器将为你获取一个新的 HTML 文档。页面重新加载新文档，并且资源被重新下载。</p><blockquote><p>根据经验：每个 HTML 文档只使用一个入口起点。</p></blockquote><h2 id="输出-output"><a href="#输出-output" class="headerlink" title="输出(output)"></a>输出(output)</h2><p>将所有的资源(assets)归拢在一起后，还需要告诉 webpack 在哪里打包应用程序。webpack 的 <code>output</code> 属性描述了如何处理归拢在一起的代码(bundled code)。<code>output</code>选项可以控制webpack如何向硬盘写入编译文件。注意，即使可以存在多个<code>entry</code>起点，但只指定一个<code>output</code>配置。</p><h3 id="简单用法"><a href="#简单用法" class="headerlink" title="简单用法"></a>简单用法</h3><p>在 webpack 中配置<code>output</code> 属性的最低要求是，将它的值设置为一个对象，包括以下两点：</p><ol><li><code>filename</code> 用于输出文件的文件名。  </li><li>目标输出目录 <code>path</code> 的绝对路径。  </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//webpack.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &apos;./src/index.js&apos;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: &apos;./home/proj/public/assets&apos;,</span><br><span class="line">    filename: &apos;bundle.js&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此配置将一个单独的 <code>bundle.js</code> 文件输出到 <code>./home/proj/public/assets</code> 目录中。</p><h3 id="多个入口起点"><a href="#多个入口起点" class="headerlink" title="多个入口起点"></a>多个入口起点</h3><p>如果配置创建了多个单独的 <code>&quot;chunk&quot;</code>（例如，使用多个入口起点或使用像 <code>CommonsChunkPlugin</code> 这样的插件），则应该使用占位符来确保每个文件具有唯一的名称。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: &apos;./src/app.js&apos;,</span><br><span class="line">    search: &apos;./src/search.js&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &apos;[name].js&apos;, //使用占位符</span><br><span class="line">    path: __dirname + &apos;/dist&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 写入到硬盘：./dist/app.js, ./dist/search.js</span><br></pre></td></tr></table></figure><h2 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h2><p>webpack的目标是，让webpack聚焦于项目中的所有资源(asset), 而浏览器不需要关注考虑这些。 webpack把每个文件(<code>.css</code>, <code>.html</code>, <code>.scss</code>, <code>.jpg</code>, <code>etc.</code>)都作为模块处理。然而webpack自身只理解JavaScript。<br>webpack loader 在文件被添加到依赖图中时，将文件源代码转换为模块。  </p><p><code>loader</code>可以使你在<code>import</code>或”加载”模块时预处理文件。因此，<code>loader</code>类似于其他构建工具中“任务(task)”，并提供了处理前端构建步骤的强大方法。</p><p>在更高层面，在webpack的配置中<code>loader</code>有两个目标：</p><ol><li>识别出应该被对应的<code>loader</code>进行转换的那些文件。(<code>test</code>属性)</li><li>转换这些文件，从而使其能够被添加到依赖图中(并且最终添加到bundle中)。(<code>use</code>属性)</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//webpack.config.js</span><br><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &apos;./path/to/my/entry/file.js&apos;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, &apos;dist&apos;),</span><br><span class="line">    filename: &apos;my-first-webpack.bundle.js&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123; </span><br><span class="line">        test: /\.txt$/,</span><br><span class="line">        use: &apos;raw-loader&apos; </span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以上配置中，对一个单独的 <code>module</code> 对象定义了 <code>rules</code> 属性，里面包含两个必须属性：<code>test</code> 和<code>use</code>。这相当于告诉 webpack 编译器，当碰到「在 <code>require()/import</code> 语句中被解析为 <code>.txt</code> 的路径」时，在对它打包之前，先使用 <code>raw-loader</code> 转换一下。</p><blockquote><p>在webpack配置中定义<code>loader</code>时，要定义在<code>module.rules</code>中，而不是<code>rules</code>。如果不这么做，webpack会给出严重警告</p></blockquote><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>例如，你可以使用<code>loader</code>告诉webpack加载<code>css</code>文件，或者将TypeScript转为JavaScript。为此，首先安装相对应的<code>loader</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -D css-loader</span><br><span class="line">npm install -D ts-loader</span><br></pre></td></tr></table></figure><p>然后指示webpack对每个<code>.css</code>使用<code>css-loader</code>, 以及对所有<code>.ts</code>文件使用<code>ts-loader</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123; test: /\.css$/, use: &apos;css-loader&apos; &#125;,</span><br><span class="line">      &#123; test: /\.ts$/, use: &apos;ts-loader&apos; &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>根据配置选项，下面的规范定义了同等的<code>loader</code>用法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;test: /\.css$/, use: &apos;css-loader&apos;&#125;</span><br><span class="line">// 等同于</span><br><span class="line">&#123;test: /\.css$/, use: [&#123;</span><br><span class="line">  loader: &apos;css-loader&apos;</span><br><span class="line">&#125;]&#125;</span><br><span class="line">// 等同于</span><br><span class="line">&#123;test: /\.css$/, loader: &apos;css-loader&apos;&#125;</span><br></pre></td></tr></table></figure><p><code>module.rules.loader</code> 是 <code>module.rules.use: [ { loader } ]</code> 的简写。</p><p>在应用程序中，有三种使用loader的方式：</p><ul><li>配置（推荐）：在webpack.config.js文件中指定loader。</li><li>内联： 在每个<code>imort</code>语句中显示指定loader。</li><li>CLI: 在<code>shell</code>命令中指定它们。</li></ul><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p><code>module.rules</code> 允许你在 webpack 配置中指定多个 <code>loader</code>。 这是展示<code>loader</code>的一种简明方式，并且有助于使代码变得简洁。同时让你对各个<code>loader</code> 有个全局概览：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">        test: /\.css$/,</span><br><span class="line">        use: [</span><br><span class="line">            &apos;style-loader&apos;,</span><br><span class="line">            &#123; loader: &apos;scss-loader&apos; &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                loader: &apos;css-loader&apos;,</span><br><span class="line">                options: &#123;</span><br><span class="line">                    modules: true</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="内联"><a href="#内联" class="headerlink" title="内联"></a>内联</h4><p>可以在<code>import</code> 语句或任何等效于 “import” 的方式中指定 loader。使用 <code>!</code> 将资源中的 loader 分开。分开的每个部分都相对于当前目录解析。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import Styles from &apos;style-loader!css-loader?modules!./styles.css&apos;</span><br></pre></td></tr></table></figure><p>通过前置所有规则及使用<code>!</code>, 可以对应覆盖到配置中的任意<code>loader</code>。<br>选项可以传递查询参数，例如 <code>?key=value&amp;foo=bar</code>，或者一个 JSON 对象，例如 <code>?{&quot;key&quot;:&quot;value&quot;,&quot;foo&quot;:&quot;bar&quot;}</code>。</p><blockquote><p>尽可能使用 <code>module.rules</code>，因为这样可以减少源码中的代码量，并且可以在出错时，更快地调试和定位 loader 中的问题。</p></blockquote><h4 id="CLI"><a href="#CLI" class="headerlink" title="CLI"></a>CLI</h4><p>你也可以通过<code>CLI</code>使用loader:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpack --module-bind jade-loader --module-bind &apos;css=style-loader!css-loader&apos;</span><br></pre></td></tr></table></figure><p>这会对<code>.jade</code>文件使用 <code>jade-loader</code>，对 <code>.css</code>文件使用 <code>style-loader</code>和 <code>css-loader</code>。</p><h3 id="Loader特性"><a href="#Loader特性" class="headerlink" title="Loader特性"></a>Loader特性</h3><ul><li>loader 支持链式传递。能够对资源使用流水线(pipeline)。一组链式的 loader 将按照先后顺序进行编译。loader 链中的第一个 loader 返回值给下一个 loader。在最后一个 loader，返回 webpack 所预期的 JavaScript。</li><li>loader 可以是同步的，也可以是异步的。</li><li>loader 运行在 Node.js 中，并且能够执行任何可能的操作。</li><li>loader 接收查询参数。用于对 loader 传递配置。</li><li>loader 也能够使用<code>options</code> 对象进行配置。</li><li>除了使用 <code>package.json</code> 常见的 <code>main</code> 属性，还可以将普通的 npm 模块导出为loader，做法是在 <code>package.json</code> 里定义一个 <code>loader</code> 字段。</li><li>插件(plugin)可以为 loader 带来更多特性。</li><li>loader 能够产生额外的任意文件。<br>loader 通过（loader）预处理函数，为 JavaScript 生态系统提供了更多能力。</li></ul><h3 id="解析Loader"><a href="#解析Loader" class="headerlink" title="解析Loader"></a>解析Loader</h3><p>loader 遵循标准的模块解析。多数情况下，loader 将从模块路径（通常将模块路径认为是<code>npm install</code>, <code>node_modules</code>）解析。<br>loader 模块需要导出为一个函数，并且使用 Node.js 兼容的 JavaScript 编写。通常使用 npm 来管理，也可以将自定义 loader 作为应用程序中的文件。按照约定，loader 通常被命名为 xxx-loader（例如 <code>json-loader</code>）。</p><h2 id="插件-plugins"><a href="#插件-plugins" class="headerlink" title="插件-plugins"></a>插件-plugins</h2><p>插件是 wepback 的支柱功能。webpack 自身也是构建于-你在 webpack 配置中用到的<strong>相同的插件系统</strong>之上！<br>插件目的在于解决 loader无法实现的<strong>其他事</strong>。<br>由于loader仅在每个文件的基础上执行转换，而插件(plugins) 常用于（但不限于）在打包模块的 “compilation” 和 “chunk” 生命周期执行操作和自定义功能。想要使用一个插件，你只需要 <code>require()</code> 它，然后把它添加到 <code>plugins</code> 数组中。<br>多数插件可以通过选项(option)自定义。你也可以在一个配置文件中因为不同目的而多次使用同一个插件，这时需要通过使用 new 来创建它的一个实例。</p><h3 id="剖析"><a href="#剖析" class="headerlink" title="剖析"></a>剖析</h3><p>webpack 插件是一个具有 <code>apply</code> 属性的 JavaScript 对象。<code>apply</code><br> 属性会被 webpack compiler 调用，并且 <code>compiler</code> 对象可在整个编译生命周期访问。通过<code>Function.prototype.apply</code>方法，你可以把任意函数作为插件传递(<code>this</code> 将指向<code>compiler</code>)。我们可以在配置中使用这样的方式来内联自定义插件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//ConsoleLogOnBuildWebpackPlugin.js</span><br><span class="line">function ConsoleLogOnBuildWebpackPlugin() &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ConsoleLogOnBuildWebpackPlugin.prototype.apply = function(compiler) &#123;</span><br><span class="line">  compiler.plugin(&apos;run&apos;, function(compiler, callback) &#123;</span><br><span class="line">    console.log(&quot;webpack 构建过程开始！！！&quot;);</span><br><span class="line"></span><br><span class="line">    callback();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>由于插件可以携带参数/选项，你必须在webpack配置中，向<code>plugins</code>属性中传入<code>new</code>实例。<br>根据webpack的用法，可以有多种方式使用插件。但是，通过配置的方式使用是比较推荐的做法。</p><h4 id="配置-推荐"><a href="#配置-推荐" class="headerlink" title="配置 (推荐)"></a>配置 (推荐)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//webpack.config.js</span><br><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;); //installed via npm</span><br><span class="line">const webpack = require(&apos;webpack&apos;); //to access built-in plugins</span><br><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line"></span><br><span class="line">const config = &#123;</span><br><span class="line">  entry: &apos;./path/to/my/entry/file.js&apos;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, &apos;dist&apos;),</span><br><span class="line">    filename: &apos;my-first-webpack.bundle.js&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123; test: /\.txt$/, use: &apos;raw-loader&apos; &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new webpack.optimize.UglifyJsPlugin(),</span><br><span class="line">    new HtmlWebpackPlugin(&#123;template: &apos;./src/index.html&apos;&#125;)</span><br><span class="line">  ]0</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module.exports = config;</span><br></pre></td></tr></table></figure><h4 id="Node-API-不推荐"><a href="#Node-API-不推荐" class="headerlink" title="Node API(不推荐)"></a>Node API(不推荐)</h4><p>即便使用 Node API，用户也应该在配置中传入 plugins 属性。<code>compiler.apply</code>并不是推荐的使用方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// some-node-script.js</span><br><span class="line">  const webpack = require(&apos;webpack&apos;); //访问 webpack 运行时(runtime)</span><br><span class="line">  const configuration = require(&apos;./webpack.config.js&apos;);</span><br><span class="line"></span><br><span class="line">  let compiler = webpack(configuration);</span><br><span class="line">  compiler.apply(new webpack.ProgressPlugin());</span><br><span class="line"></span><br><span class="line">  compiler.run(function(err, stats) &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是<a href="https://doc.webpack-china.org/" target="_blank" rel="noopener">webpack</a>中比较重要的四个概念，在平时开发过程中会经常遇到。里面还可以有很多的详细配置，需要我们在项目开发的过程中慢慢了解。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;webpack&lt;/code&gt; 是一个当下最流行的前端资源的模块打包器。当 &lt;code&gt;webpack&lt;/code&gt; 处理应用程序时，它会递归地构建一个依赖关系图(&lt;code&gt;dependency graph&lt;/code&gt;)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成少量的&lt;code&gt;bundle&lt;/code&gt; - 通常只有一个，由浏览器加载。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="webpack" scheme="http://weiqinl.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>ECMAScript6-let与const命令详解</title>
    <link href="http://weiqinl.com/2017/08/12/ECMAScript6-let%E4%B8%8Econst%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"/>
    <id>http://weiqinl.com/2017/08/12/ECMAScript6-let与const命令详解/</id>
    <published>2017-08-12T03:13:52.000Z</published>
    <updated>2018-04-17T03:13:40.034Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>《ECMAScript入门》是一本开源的JavaScript语言教程，全面介绍ECMAScript6新引入的语法特性。<br>let和const命令，是第一章开始介绍，也是比较基础的知识。我在学习之后，把它总结记录下来，以便自己以后复习查看。<br><strong>以下代码，于Chrome57 DevTools运行</strong><br> <strong>node为6.3版本</strong></p><h2 id="先总结"><a href="#先总结" class="headerlink" title="先总结"></a>先总结</h2><p> 先总结区别，再分别阐述</p><h3 id="let-与-const-相同点和区别"><a href="#let-与-const-相同点和区别" class="headerlink" title="let 与 const 相同点和区别"></a>let 与 const 相同点和区别</h3><p>1：<code>let</code>命令用来声明变量，用法类似于<code>var</code>，但是所声明的变量。<br>   <code>const</code>声明一个只读的常量，一旦声明，常量的值就不能改变。<br>   <code>const</code>保证的是内存地址不得改动。常量（内存地址保存的是值），复合类型的数据（内存地址保存的是指针）<br>2：两者都不存在变量提升。<br>3：两者都有暂时性死区(TDZ)。<br>4：两者都不允许重复声明。<br>5：两者为JavaScript新增了块级作用域。两者作用域，只在声明所在的块级作用域有效。<br><a id="more"></a></p><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><h3 id="let命令介绍"><a href="#let命令介绍" class="headerlink" title="let命令介绍"></a>let命令介绍</h3><p><code>let</code>命令，用来声明变量。它的用法类似于<code>var</code>, 但是所声明的变量，只在<code>let</code>命令所在的代码块内有效。<br>浏览器中的结果 <img src="http://upload-images.jianshu.io/upload_images/1808701-f3a757e07cfaec42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="let命令"></p><p>上面代码在代码块之中，分别用<code>let</code>和<code>var</code>声明了两个变量。然后在代码块之外调用这两个变量，结果<code>let</code>声明的变量报错，<code>var</code>声明的变量返回了正确的值。这表明，<code>let</code>声明的变量只在它所在的代码块有效。上面代码在代码块之中，分别用<code>let</code>和<code>var</code>声明了两个变量。然后在代码块之外调用这两个变量，结果<code>let</code>声明的变量报错，<code>var</code>声明的变量返回了正确的值。这表明，<code>let</code>声明的变量只在它所在的代码块有效。</p><h3 id="let实用举例"><a href="#let实用举例" class="headerlink" title="let实用举例"></a>let实用举例</h3><p> <code>for</code>循环的计数器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for (let i =0; i &lt; 10; i++) &#123;&#125;</span><br><span class="line">console.log(i) // ReferenceError: i is not defined</span><br></pre></td></tr></table></figure></p><p> 浏览器中的结果<img src="http://upload-images.jianshu.io/upload_images/1808701-b40ad1bad6eb2dc8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="for循环的计数器"></p><p> 上面代码中，计数器<code>i</code>只在<code>for</code>循环体内有效，在循环体外引用就会报错。</p><p> 下面的代码如果使用<code>var</code>, 最后输出的是<code>10</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var  a  =   [];</span><br><span class="line">for  (var  i  =  0;  i  &lt;  10;  i++)  &#123;</span><br><span class="line">  a[i]  =   function ()  &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[6](); // 10</span><br></pre></td></tr></table></figure></p><p>浏览器中的结果 <img src="http://upload-images.jianshu.io/upload_images/1808701-11e13d162f5e3a7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="var- for循环"></p><p>   上面代码中，变量<code>i</code>是<code>var</code>命令声明的，在全局范围内都有效，所以全局只有一个变量<code>i</code>。每一次循环，变量<code>i</code>的值都会发生改变，而循环内被赋给数组<code>a</code>的函数内部的<code>console.log(i)</code>，里面的<code>i</code>指向的就是全局的<code>i</code>。也就是说，所有数组<code>a</code>的成员里面的<code>i</code>，指向的都是同一个<code>i</code>，导致运行时输出的是最后一轮的<code>i</code>的值，也就是<code>10</code>。</p><p>   如果使用<code>let</code>, 声明的变量仅在<a href="#blockscope">块级作用域</a>内有效，最后输出的是<code>6</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var  a  =   [];</span><br><span class="line">for  (var  i  =  0;  i  &lt;  10;  i++)  &#123;</span><br><span class="line">  a[i]  =   function ()  &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[6](); // 6</span><br></pre></td></tr></table></figure><p>浏览器结果<img src="http://upload-images.jianshu.io/upload_images/1808701-a556a84c1e41a951.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="let-for循环"></p><p>上面代码中，变量<code>i</code>是<code>let</code>声明的，当前的<code>i</code>只在本轮循环有效，所以每一次循环的<code>i</code>其实都是一个新的变量，所以最后输出的是<code>6</code>。你可能会问，如果每一轮循环的变量<code>i</code>都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量<code>i</code>时，就在上一轮循环的基础上进行计算。</p><p>另外，<code>for</code>循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (let i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">  let i = &apos;abc&apos;;</span><br><span class="line">  console.log(i);</span><br><span class="line">&#125;</span><br><span class="line">// abc</span><br><span class="line">// abc</span><br><span class="line">// abc</span><br></pre></td></tr></table></figure><p>浏览器结果 <img src="http://upload-images.jianshu.io/upload_images/1808701-5a6f224a1dc3e5b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="let-for循环-父子作用域"></p><p>上面代码正确运行，输出了3次<code>abc</code>。这表明函数内部的变量<code>i</code>与循环变量<code>i</code>不在同一个作用域，有各自单独的作用域。</p><h2 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h2><p><code>var</code>命令会发生<code>变量提升</code>现象，即变量可以在声明之前使用，值为<code>undefined</code>。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。</p><p>为了纠正这种现象，<code>let</code>命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// var 的情况</span><br><span class="line">console.log(foo); // 输出undefined</span><br><span class="line">var foo = 2;</span><br><span class="line"> </span><br><span class="line">// let 的情况</span><br><span class="line">console.log(bar); // 报错ReferenceError</span><br><span class="line">let bar = 2;</span><br></pre></td></tr></table></figure><p>浏览器结果<img src="http://upload-images.jianshu.io/upload_images/1808701-4eb9702e386ba651.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="不存在变量提升"></p><p>上面代码中，变量<code>foo</code>用<code>var</code>命令声明，会发生变量提升，即脚本开始运行时，变量<code>foo</code>已经存在了，但是没有值，所以会输出<code>undefined</code>。变量<code>bar</code>用<code>let</code>命令声明，不会发生变量提升。这表示在声明它之前，变量<code>bar</code>是不存在的，这时如果用到它，就会抛出一个错误。</p><h2 id="暂时性死区（TDZ）"><a href="#暂时性死区（TDZ）" class="headerlink" title="暂时性死区（TDZ）"></a>暂时性死区（TDZ）</h2><p>只要块级作用域内存在<code>let</code>命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var tmp = 123;</span><br><span class="line"> </span><br><span class="line">if (true) &#123;</span><br><span class="line">  tmp = &apos;abc&apos;; // ReferenceError</span><br><span class="line">  let tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>浏览器中的结果<img src="http://upload-images.jianshu.io/upload_images/1808701-759e74b94c15487a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="暂时性死区(TDZ)"></p><p>上面代码中，存在全局变量<code>tmp</code>,但是块级作用域内<code>let</code>又声明了一个局部变量<code>tmp</code>,导致后者绑定这个块级作用域，所以在<code>let</code>声明变量前，对<code>tmp</code>赋值会报错。</p><p>ES6明确规定，如果区块中存在<code>let</code>和<code>const</code>命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。</p><p>总之，在代码块内，使用<code>let</code>命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if (true) &#123;</span><br><span class="line">  // TDZ开始</span><br><span class="line">  tmp = &apos;abc&apos;; // ReferenceError</span><br><span class="line">  console.log(tmp); // ReferenceError</span><br><span class="line"> </span><br><span class="line">  let tmp; // TDZ结束</span><br><span class="line">  console.log(tmp); // undefined</span><br><span class="line"> </span><br><span class="line">  tmp = 123;</span><br><span class="line">  console.log(tmp); // 123</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>浏览器结果<br><img src="http://upload-images.jianshu.io/upload_images/1808701-49873f4ad0ada734.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ReferenceError"><br><img src="http://upload-images.jianshu.io/upload_images/1808701-b73cc279b0d4184e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ReferenceError"></p><p><img src="http://upload-images.jianshu.io/upload_images/1808701-078381fe53f0cf35.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="正常情况"></p><p>上面代码中，在<code>let</code>命令声明变量<code>tmp</code>之前，都属于变量<code>tmp</code>的“死区”。</p><p>“暂时性死区”也意味着<code>typeof</code>不再是一个百分之百安全的操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typeof x; // ReferenceError</span><br><span class="line">let x;</span><br></pre></td></tr></table></figure><p>浏览器结果<img src="http://upload-images.jianshu.io/upload_images/1808701-bd84a9111223a679.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="typeof不再是一个百分之百安全的操作"></p><p>上面代码中，变量<code>x</code>使用<code>let</code>命令声明，所以在声明之前，都属于<code>x</code>的“死区”，只要用到该变量就会报错。因此，<code>typeof</code>运行时就会抛出一个<code>ReferenceError</code>。</p><p>作为比较，如果一个变量根本没有被声明，使用<code>typeof</code>反而不会报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typeof undeclared_variable // &quot;undefined&quot;</span><br></pre></td></tr></table></figure><p>浏览器结果<img src="http://upload-images.jianshu.io/upload_images/1808701-9d7d593750050616.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="typeof对未声明的变量有用"></p><p>上面代码中，<code>undeclared_variable</code>是一个不存在的变量名，结果返回“undefined”。所以，在没有<code>let</code>之前，<code>typeof</code>运算符是百分之百安全的，永远不会报错。现在这一点不成立了。这样的设计是为了让大家养成良好的编程习惯，变量一定要在声明之后使用，否则就报错。</p><p>有些“死区”比较隐蔽，不太容易发现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function bar(x = y, y = 2) &#123;</span><br><span class="line">  return [x, y];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">bar(); // 报错</span><br></pre></td></tr></table></figure><p>浏览器结果<img src="http://upload-images.jianshu.io/upload_images/1808701-103ff020e54d8964.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="函数参数TDZ"></p><p>上面代码中，调用<code>bar</code>函数之所以报错（某些实现可能不报错），是因为参数<code>x</code>默认值等于另一个参数<code>y</code>，而此时<code>y</code>还没有声明，属于”死区“。如果<code>y</code>的默认值是<code>x</code>，就不会报错，因为此时<code>x</code>已经声明了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function bar(x = 2, y = x) &#123;</span><br><span class="line">  return [x, y];</span><br><span class="line">&#125;</span><br><span class="line">bar(); // [2, 2]</span><br></pre></td></tr></table></figure><p>浏览器结果<img src="http://upload-images.jianshu.io/upload_images/1808701-3a5e506b1c8b26fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>另外，下面的代码也会报错，与<code>var</code>的行为不同。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 不报错</span><br><span class="line">var x = x;</span><br><span class="line"> </span><br><span class="line">// 报错</span><br><span class="line">let x = x;</span><br><span class="line">// ReferenceError: x is not defined</span><br></pre></td></tr></table></figure></p><p>浏览器结果<img src="http://upload-images.jianshu.io/upload_images/1808701-519edc14946bb783.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="let定义变量的TDZ"></p><p>上面代码报错，也是因为暂时性死区。使用<code>let</code>声明变量时，只要变量在还没有声明完成前使用，就会报错。上面这行就属于这个情况，在变量<code>x</code>的声明语句还没有执行完成前，就去取<code>x</code>的值，导致报错”x 未定义“。</p><p>ES6 规定暂时性死区和<code>let</code>、<code>const</code>语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在 ES5 是很常见的，现在有了这种规定，避免此类错误就很容易了。</p><p>总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</p><h2 id="不允许重复声明"><a href="#不允许重复声明" class="headerlink" title="不允许重复声明"></a>不允许重复声明</h2><p><code>let</code>不允许在相同作用域内，重复声明同一个变量。<br>浏览器结果<br><img src="http://upload-images.jianshu.io/upload_images/1808701-fc62f8b9a63d3720.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="let不允许重复声明1"></p><p><img src="http://upload-images.jianshu.io/upload_images/1808701-c3ba51139ac69619.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="let不允许重复声明2"></p><p><img src="http://upload-images.jianshu.io/upload_images/1808701-6b01394911253746.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="let不允许重复声明3"></p><p> 因此，不能在函数内部重新声明参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function func(arg) &#123;</span><br><span class="line">  let arg; //在chrome浏览器下，不报错。使用node执行，会报错。</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function func(arg) &#123;</span><br><span class="line">  &#123;</span><br><span class="line">    let arg;//在chrome浏览器下，不报错。使用node执行，也不报错。</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>浏览器环境和node执行情况</p><p><img src="http://upload-images.jianshu.io/upload_images/1808701-69e0b945a528bd31.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="浏览器环境下执行"></p><p><img src="http://upload-images.jianshu.io/upload_images/1808701-ff50e440ab0de95b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="node6.3环境下执行"></p><h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2><p>块级作用域，没有返回值。</p><h3 id="为什么需要块级作用域"><a href="#为什么需要块级作用域" class="headerlink" title="为什么需要块级作用域?"></a>为什么需要块级作用域?</h3><p>ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。  </p><p>第一种场景，内层变量可能会覆盖外层变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var tmp = new Date();</span><br><span class="line"></span><br><span class="line">function f() &#123;</span><br><span class="line">  console.log(tmp);</span><br><span class="line">  if (false) &#123;</span><br><span class="line">    var tmp = &apos;hello world&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(); // undefined</span><br></pre></td></tr></table></figure></p><p>浏览器结果<img src="http://upload-images.jianshu.io/upload_images/1808701-55389e99c599d827.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="内层变量可能会覆盖外层变量"></p><p>上面代码的原意是，<code>if</code>代码块的外部使用外层的<code>tmp</code>变量，内部使用内层的<code>tmp</code>变量。但是，函数<code>f</code>执行后，输出结果为<code>undefined</code>，原因在于变量提升，导致内层的<code>tmp</code>变量覆盖了外层的<code>tmp</code>变量。</p><p>第二种场景，用来计数的循环变量泄露为全局变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var s = &apos;hello&apos;;</span><br><span class="line"></span><br><span class="line">for (var i = 0; i &lt; s.length; i++) &#123;</span><br><span class="line">  console.log(s[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(i); // 5</span><br></pre></td></tr></table></figure><p>浏览器结果<img src="http://upload-images.jianshu.io/upload_images/1808701-e89626346bdfaefd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="用来计数的循环变量泄露为全局变量"></p><p>上面代码中，变量<code>i</code>只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。</p><h3 id="ES6的块级作用域"><a href="#ES6的块级作用域" class="headerlink" title="ES6的块级作用域"></a>ES6的块级作用域</h3><p><code>let</code>实际上为 JavaScript 新增了块级作用域。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function f1() &#123;</span><br><span class="line">  let n = 5;</span><br><span class="line">  if (true) &#123;</span><br><span class="line">    let n = 10;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(n); // 5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>浏览器结果<img src="http://upload-images.jianshu.io/upload_images/1808701-63ef326fdc2aa06e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="let块级作用域"></p><p>上面的函数有两个代码块，都声明了变量<code>n</code>，运行后输出5。这表示外层代码块不受内层代码块的影响。如果两次都使用<code>var</code>定义变量<code>n</code>，最后输出的值才是10。</p><p>浏览器结果<img src="http://upload-images.jianshu.io/upload_images/1808701-2c1adffb868fd796.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="let块级作用域"></p><p>ES6 允许块级作用域的任意嵌套。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&#123;&#123;&#123;let insane = &apos;Hello World&apos;&#125;&#125;&#125;&#125;&#125;;</span><br></pre></td></tr></table></figure><p>上面代码使用了一个五层的块级作用域。外层作用域无法读取内层作用域的变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&#123;&#123;</span><br><span class="line">  &#123;let insane = &apos;Hello World&apos;&#125;</span><br><span class="line">  console.log(insane); // 报错</span><br><span class="line">&#125;&#125;&#125;&#125;;</span><br></pre></td></tr></table></figure><p>浏览器结果<img src="http://upload-images.jianshu.io/upload_images/1808701-60b9f71a77f25a33.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="let块级作用域"></p><p>内层作用域可以定义外层作用域的同名变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&#123;&#123;</span><br><span class="line">  let insane = &apos;Hello World&apos;;</span><br><span class="line">  &#123;let insane = &apos;Hello World&apos;&#125;</span><br><span class="line">&#125;&#125;&#125;&#125;;</span><br></pre></td></tr></table></figure><p>块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// IIFE 写法</span><br><span class="line">(function () &#123;</span><br><span class="line">  var tmp = ...;</span><br><span class="line">  ...</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line">// 块级作用域写法</span><br><span class="line">&#123;</span><br><span class="line">  let tmp = ...;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="块级作用域与函数声明"><a href="#块级作用域与函数声明" class="headerlink" title="块级作用域与函数声明"></a>块级作用域与函数声明</h3><ul><li>允许在块级作用域内声明函数。</li><li>函数声明类似于<code>var</code>，即会提升到全局作用域或函数作用域的头部。</li><li>同时，函数声明还会提升到所在的块级作用域的头部。</li></ul><h2 id="const命令"><a href="#const命令" class="headerlink" title="const命令"></a>const命令</h2><h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><p><code>const</code>也是用来声明变量，但是声明的是一个只读的常量。一旦声明，常量的值就不能改变。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const PI = 3.1415;</span><br><span class="line">PI // 3.1415</span><br><span class="line"></span><br><span class="line">PI = 3;</span><br><span class="line">// TypeError: Assignment to constant variable.</span><br></pre></td></tr></table></figure><p>浏览器结果<img src="http://upload-images.jianshu.io/upload_images/1808701-a0ac032f8df48178.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="const声明之后不可变"></p><p>上面代码表明改变常量的值会报错。</p><p><code>const</code>声明的变量不得改变值，这意味着，<code>const</code>一旦声明变量，就必须立即初始化，不能留到以后赋值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const foo;</span><br><span class="line">// SyntaxError: Missing initializer in const declaration</span><br></pre></td></tr></table></figure><p>浏览器结果<img src="http://upload-images.jianshu.io/upload_images/1808701-c94b2d1e8ca383c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="const声明之后需要立即初始化"></p><p>上面代码表示，对于<code>const</code>来说，只声明不赋值，就会报错。</p><p><code>const</code>的作用域与<code>let</code>命令相同：只在声明所在的块级作用域内有效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (true) &#123;</span><br><span class="line">  const MAX = 5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MAX // Uncaught ReferenceError: MAX is not defined</span><br></pre></td></tr></table></figure><p>浏览器结果<img src="http://upload-images.jianshu.io/upload_images/1808701-5345ea3235c3fab7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="const声明只在块级作用域有效"></p><p><code>const</code>命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (true) &#123;</span><br><span class="line">  console.log(MAX); // ReferenceError</span><br><span class="line">  const MAX = 5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>浏览器结果<img src="http://upload-images.jianshu.io/upload_images/1808701-6713c6f28482ea8d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="const命令声明的常量不提升"></p><p>上面代码在常量<code>MAX</code>声明之前就调用，结果报错。</p><p><code>const</code>声明的常量，也与<code>let</code>一样不可重复声明。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var message = &quot;Hello!&quot;;</span><br><span class="line">let age = 25;</span><br><span class="line"></span><br><span class="line">// 以下两行都会报错</span><br><span class="line">const message = &quot;Goodbye!&quot;;</span><br><span class="line">const age = 30;</span><br></pre></td></tr></table></figure><p>浏览器结果</p><p><img src="http://upload-images.jianshu.io/upload_images/1808701-4b2aa30ee52fad97.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="const声明的常量不可重复声明1"></p><p><img src="http://upload-images.jianshu.io/upload_images/1808701-46e1ae1b8211487c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="const声明的常量不可重复声明2"></p><p>对于复合类型的变量，变量名不指向数据，而是指向数据所在的地址。 const命令只是保证变量名指向的地址不变，并不保证该地址的数据不变，所以，将一个对象声明为常量必须非常小心。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const foo = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">// 为 foo 添加一个属性，可以成功</span><br><span class="line">foo.prop = 123;</span><br><span class="line">foo.prop // 123</span><br><span class="line"></span><br><span class="line">// 将 foo 指向另一个对象，就会报错</span><br><span class="line">foo = &#123;&#125;; // TypeError:  Assignment to constant variable.</span><br></pre></td></tr></table></figure><p>浏览器结果<br><img src="http://upload-images.jianshu.io/upload_images/1808701-2f8aee36ccadb4c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="将一个对象声明为常量需要小心"></p><p>上面代码中，常量<code>foo</code>储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把<code>foo</code>指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。</p><h2 id="跨模块常量"><a href="#跨模块常量" class="headerlink" title="跨模块常量"></a>跨模块常量</h2><p>上面说过，const声明的常量只在当前代码块有效。如果想设置跨模块的常量，可以采用下面的写法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// constants.js 模块</span><br><span class="line">export const A = 1;</span><br><span class="line">export const B = 3;</span><br><span class="line">export const C = 4;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//test1.js 模块</span><br><span class="line">import * as constans from &apos;./constants&apos;;</span><br><span class="line">console.log(constants.A); // 1</span><br><span class="line">console.log(constants.B); // 3</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// test2.js 模块</span><br><span class="line">import &#123;A, B&#125; from &apos;./constants&apos;;</span><br><span class="line">console.log(A); //1</span><br><span class="line">console.log(B); //3</span><br></pre></td></tr></table></figure><p>这里其实用到了Module（模块）的导入导出功能。以后会讲到。</p><h2 id="全局对象的属性"><a href="#全局对象的属性" class="headerlink" title="全局对象的属性"></a>全局对象的属性</h2><p>全局对象是最顶层的对象，在浏览器环境指的是<code>window</code>对象，在Node指的是<code>global</code>对象。ES5之中，顶层对象的属性与全局变量是等价的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">window.a = 1;</span><br><span class="line">a //1</span><br><span class="line"></span><br><span class="line">a = 2;</span><br><span class="line">window.a //2</span><br></pre></td></tr></table></figure></p><p>浏览器结果<img src="http://upload-images.jianshu.io/upload_images/1808701-f4d82eff1d3b4305.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="全局对象属性"></p><p>上面代码中，全局对象的属性赋值与全局变量的赋值，是同一件事。（对于Node.js来说，这一条只对REPL环境适用，模块环境中，全局变量必须显示声明成global对象的属性。）这种规定被市委JavaScript语言的一大问题。因为很容易不知不觉就创建了全局变量。<br>ES6为了改变这一点，一方面规定，为了保持兼容性，<code>var</code>命令和<code>function</code>命令声明的全局变量，依旧是全局对象的属性；另一方面规定，<code>let</code>命令、<code>const</code>命令和<code>class</code>命令声明的全局变量，不属于全局对象的属性。也就是说，从ES6开始，全局变量将逐步与顶层对象的属性脱钩。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a = 1;</span><br><span class="line">// 如果在Node的REPL环境，可以写成global.a</span><br><span class="line">// 或者采用通用方法，写成this.a</span><br><span class="line">window.a // 1</span><br><span class="line"></span><br><span class="line">let b = 1;</span><br><span class="line">window.b // undefined</span><br></pre></td></tr></table></figure></p><p>浏览器结果<img src="http://upload-images.jianshu.io/upload_images/1808701-69073bbb184afa91.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="全局对象属性看由谁定义"></p><p>上面代码中，全局变量<code>a</code>由<code>var</code>命令声明，所以它是全局对象的属性；全局变量<code>b</code>由<code>let</code>命令声明，所以它不是全局对象的属性，返回<code>undefined</code>。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://es6.ruanyifeng.com/#docs/let" target="_blank" rel="noopener">let 和 const 命令</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;《ECMAScript入门》是一本开源的JavaScript语言教程，全面介绍ECMAScript6新引入的语法特性。&lt;br&gt;let和const命令，是第一章开始介绍，也是比较基础的知识。我在学习之后，把它总结记录下来，以便自己以后复习查看。&lt;br&gt;&lt;strong&gt;以下代码，于Chrome57 DevTools运行&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;node为6.3版本&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;先总结&quot;&gt;&lt;a href=&quot;#先总结&quot; class=&quot;headerlink&quot; title=&quot;先总结&quot;&gt;&lt;/a&gt;先总结&lt;/h2&gt;&lt;p&gt; 先总结区别，再分别阐述&lt;/p&gt;
&lt;h3 id=&quot;let-与-const-相同点和区别&quot;&gt;&lt;a href=&quot;#let-与-const-相同点和区别&quot; class=&quot;headerlink&quot; title=&quot;let 与 const 相同点和区别&quot;&gt;&lt;/a&gt;let 与 const 相同点和区别&lt;/h3&gt;&lt;p&gt;1：&lt;code&gt;let&lt;/code&gt;命令用来声明变量，用法类似于&lt;code&gt;var&lt;/code&gt;，但是所声明的变量。&lt;br&gt;   &lt;code&gt;const&lt;/code&gt;声明一个只读的常量，一旦声明，常量的值就不能改变。&lt;br&gt;   &lt;code&gt;const&lt;/code&gt;保证的是内存地址不得改动。常量（内存地址保存的是值），复合类型的数据（内存地址保存的是指针）&lt;br&gt;2：两者都不存在变量提升。&lt;br&gt;3：两者都有暂时性死区(TDZ)。&lt;br&gt;4：两者都不允许重复声明。&lt;br&gt;5：两者为JavaScript新增了块级作用域。两者作用域，只在声明所在的块级作用域有效。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://weiqinl.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>在webpack中使用Code Splitting--代码分割来实现vue中的懒加载</title>
    <link href="http://weiqinl.com/2017/08/07/%E5%9C%A8webpack%E4%B8%AD%E4%BD%BF%E7%94%A8Code-Splitting-%E4%BB%A3%E7%A0%81%E5%88%86%E5%89%B2%E6%9D%A5%E5%AE%9E%E7%8E%B0vue%E4%B8%AD%E7%9A%84%E6%87%92%E5%8A%A0%E8%BD%BD/"/>
    <id>http://weiqinl.com/2017/08/07/在webpack中使用Code-Splitting-代码分割来实现vue中的懒加载/</id>
    <published>2017-08-07T09:05:59.000Z</published>
    <updated>2018-04-17T03:13:40.040Z</updated>
    
    <content type="html"><![CDATA[<p>当<a href="https://cn.vuejs.org/index.html" target="_blank" rel="noopener">Vue</a>应用程序越来越大，使用<a href="https://doc.webpack-china.org/guides/code-splitting/" target="_blank" rel="noopener">Webpack的代码分割</a>来<a href="https://doc.webpack-china.org/guides/lazy-loading/" target="_blank" rel="noopener">懒加载</a>组件，路由或者<a href="https://vuex.vuejs.org/zh-cn/" target="_blank" rel="noopener">Vuex</a>模块, 只有在需要时候才加载代码。</p><p>我们可以在Vue应用程序中在三个不同层级应用懒加载和代码分割:</p><ul><li>组件，也称为<a href="https://cn.vuejs.org/v2/guide/components.html#异步组件" target="_blank" rel="noopener">异步组件</a></li><li>路由</li><li>Vuex 模块</li></ul><p>但是他们都有一些共同之处：自webpack2.0版本之后,他们都使用<a href="https://github.com/tc39/proposal-dynamic-import" target="_blank" rel="noopener">动态导入</a>[译者注：也可以参考<a href="https://doc.webpack-china.org/guides/code-splitting/#dynamic-imports" target="_blank" rel="noopener">这个</a>]。<br><a id="more"></a></p><h2 id="Vue组件中的懒加载"><a href="#Vue组件中的懒加载" class="headerlink" title="Vue组件中的懒加载"></a>Vue组件中的懒加载</h2><p>这在Egghead上的<a href="https://egghead.io/lessons/load-components-when-needed-with-vue-async-components" target="_blank" rel="noopener">“使用Vue异步组件按需加载组件”</a>视频中有很好的解释。<br>这就像在注册组件时使用<code>import</code>函数一样简单：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;AsyncCmp&apos;, () =&gt; import(&apos;./AsyncCmp&apos;)</span><br></pre></td></tr></table></figure></p><p>并在本地注册使用:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">// ...</span><br><span class="line">components: &#123;</span><br><span class="line">&apos;AsyncCmp&apos;: () =&gt; import(&apos;./AsyncCmp&apos;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>通过包装<code>import</code>函数进入到箭头函数，Vue将会在它被请求的时候执行加载这个模块。</p><p>如果组件导入使用<a href="http://2ality.com/2014/09/es6-modules-final.html#named-exports-several-per-module" target="_blank" rel="noopener">命名导出</a>[译者注：模块的导入导出，可以参考<a href="http://es6.ruanyifeng.com/#docs/module" target="_blank" rel="noopener">阮老师的文章</a>]，则可以在返回的Promise上使用对象解构。<br>例如，对于来自<a href="https://github.com/JosephusPaye/Keen-UI" target="_blank" rel="noopener">KeenUI</a>的UiAlert组件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">components: &#123;</span><br><span class="line">  UiAlert: () =&gt; import(&apos;keen-ui&apos;).then((&#123; UiAlert &#125;) =&gt; UiAlert)</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><h2 id="Vue路由中的懒加载"><a href="#Vue路由中的懒加载" class="headerlink" title="Vue路由中的懒加载"></a>Vue路由中的懒加载</h2><p>Vue路由器内置支持<a href="https://router.vuejs.org/zh-cn/advanced/lazy-loading.html" target="_blank" rel="noopener">懒加载</a>。这就像用<code>import</code>函数导入组件一样简单。看个例子，我们想在 <em>/login</em> 路由中使用懒加载一个Login组件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Instead of: import Login from &apos;./login&apos;</span><br><span class="line">// 替换: import Login from &apos;./login&apos;</span><br><span class="line">const Login = () =&gt; import(&apos;./login&apos;)</span><br><span class="line"></span><br><span class="line">new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; path: &apos;/login&apos;, component: Login &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h2 id="懒加载Vuex模块"><a href="#懒加载Vuex模块" class="headerlink" title="懒加载Vuex模块"></a>懒加载Vuex模块</h2><p>Vuex有一种<code>registerModule</code>方法可以让我们动态地创建Vuex模块。如果我们考虑到该<code>import</code>功能将ES模块作为有效载荷返回promise[原文： If we take into account that import function returns a promise with the ES Module as the payload]，我们可以使用它来懒加载模块：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const store = new Vuex.Store()</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">// Assume there is a &quot;login&quot; module we wanna load</span><br><span class="line">// 设想 我们需要加载一个&quot;login&quot;模块</span><br><span class="line">import(&apos;./store/login&apos;).then(loginModule =&gt; &#123;</span><br><span class="line">  store.registerModule(&apos;login&apos;, loginModule)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>Vue和Webpack使用懒加载非常简单。使用您刚刚阅读的内容，您可以从不同方面开始分割应用程序，并在需要时加载应用程序，从而减轻应用程序的初始加载。</p><p>ps: 这篇文章，基本上是翻译过来的。感谢作者<a href="https://alexjoverm.github.io" target="_blank" rel="noopener">Alex Jover</a><br>原文链接：<br><a href="https://alexjoverm.github.io/2017/07/16/Lazy-load-in-Vue-using-Webpack-s-code-splitting/" target="_blank" rel="noopener">Lazy Loading in Vue using Webpack’s Code Splitting</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当&lt;a href=&quot;https://cn.vuejs.org/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Vue&lt;/a&gt;应用程序越来越大，使用&lt;a href=&quot;https://doc.webpack-china.org/guides/code-splitting/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Webpack的代码分割&lt;/a&gt;来&lt;a href=&quot;https://doc.webpack-china.org/guides/lazy-loading/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;懒加载&lt;/a&gt;组件，路由或者&lt;a href=&quot;https://vuex.vuejs.org/zh-cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Vuex&lt;/a&gt;模块, 只有在需要时候才加载代码。&lt;/p&gt;
&lt;p&gt;我们可以在Vue应用程序中在三个不同层级应用懒加载和代码分割:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;组件，也称为&lt;a href=&quot;https://cn.vuejs.org/v2/guide/components.html#异步组件&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;异步组件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;路由&lt;/li&gt;
&lt;li&gt;Vuex 模块&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是他们都有一些共同之处：自webpack2.0版本之后,他们都使用&lt;a href=&quot;https://github.com/tc39/proposal-dynamic-import&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;动态导入&lt;/a&gt;[译者注：也可以参考&lt;a href=&quot;https://doc.webpack-china.org/guides/code-splitting/#dynamic-imports&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这个&lt;/a&gt;]。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://weiqinl.com/tags/javascript/"/>
    
      <category term="vue" scheme="http://weiqinl.com/tags/vue/"/>
    
      <category term="webpack" scheme="http://weiqinl.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>cursor属性-显示的光标的类型(形状)的用法和定义</title>
    <link href="http://weiqinl.com/2017/07/04/cursor%E5%B1%9E%E6%80%A7-%E6%98%BE%E7%A4%BA%E7%9A%84%E5%85%89%E6%A0%87%E7%9A%84%E7%B1%BB%E5%9E%8B-%E5%BD%A2%E7%8A%B6-%E7%9A%84%E7%94%A8%E6%B3%95%E5%92%8C%E5%AE%9A%E4%B9%89/"/>
    <id>http://weiqinl.com/2017/07/04/cursor属性-显示的光标的类型-形状-的用法和定义/</id>
    <published>2017-07-04T02:09:56.000Z</published>
    <updated>2018-04-17T03:13:40.036Z</updated>
    
    <content type="html"><![CDATA[<p>在网页布局的时候，在特定的地方，光标形状各有区别。这个时候，就需要用到css的cursor属性。根据自身需要选择设置鼠标指针样式。</p><h2 id="定义和用法"><a href="#定义和用法" class="headerlink" title="定义和用法"></a>定义和用法</h2><p>cursor 属性规定要显示的光标的类型（形状）。<br>该属性定义了鼠标指针放在一个元素边界范围内时所用的光标形状（不过 CSS2.1 没有定义由哪个边界确定这个范围）。<br><a id="more"></a></p><table><thead><tr><th style="text-align:left">默认值：</th><th style="text-align:left">auto</th></tr></thead><tbody><tr><td style="text-align:left">继承性：</td><td style="text-align:left">yes</td></tr><tr><td style="text-align:left">版本：</td><td style="text-align:left">CSS2</td></tr><tr><td style="text-align:left">JavaScript 语法：</td><td style="text-align:left">object.style.cursor=”crosshair”</td></tr></tbody></table><h2 id="可能的值"><a href="#可能的值" class="headerlink" title="可能的值"></a>可能的值</h2><p>图片测试于： chrome 版本 56.0.2924.87  //   Firefor  版本 51.0.1 (32 位)   //   IE 8.0</p><table><thead><tr><th style="text-align:left">值</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">url</td><td style="text-align:left">需使用的自定义光标的 URL。注释：请在此列表的末端始终定义一种普通的光标，以防没有由 URL 定义的可用光标。</td></tr><tr><td style="text-align:left">default</td><td style="text-align:left">默认光标（通常是一个箭头） <img src="http://upload-images.jianshu.io/upload_images/1808701-ea14d1b25c4074da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="cursor(default).png"></td></tr><tr><td style="text-align:left">auto</td><td style="text-align:left">默认。浏览器设置的光标。<img src="http://upload-images.jianshu.io/upload_images/1808701-4cd164e263e7bede.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="cursor(auto).png"></td></tr><tr><td style="text-align:left">crosshair</td><td style="text-align:left">光标呈现为十字线。<img src="http://upload-images.jianshu.io/upload_images/1808701-6b234e0f924d107c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="cursor(crosshari)"></td></tr><tr><td style="text-align:left">pointer</td><td style="text-align:left">光标呈现为指示链接的指针（一只手）  <img src="http://upload-images.jianshu.io/upload_images/1808701-0baeef4ab31bcd4c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="cursor(pointer).png"></td></tr><tr><td style="text-align:left">move</td><td style="text-align:left">此光标指示某对象可被移动。  <img src="http://upload-images.jianshu.io/upload_images/1808701-a499daa5cb8ebdca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="cursor(move).png"></td></tr><tr><td style="text-align:left">e-resize</td><td style="text-align:left">此光标指示矩形框的边缘可被向右（东）移动。<img src="http://upload-images.jianshu.io/upload_images/1808701-5fdfe5e6e86a623b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="cursor(e-resize).png"></td></tr><tr><td style="text-align:left">ne-resize</td><td style="text-align:left">此光标指示矩形框的边缘可被向上及向右移动（北/东）。  <img src="http://upload-images.jianshu.io/upload_images/1808701-3027469e8ef6c1f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="cursor(ne-resize).png"></td></tr><tr><td style="text-align:left">nw-resize</td><td style="text-align:left">此光标指示矩形框的边缘可被向上及向左移动（北/西）。<img src="http://upload-images.jianshu.io/upload_images/1808701-3b7ae7e67afb3004.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="cursor(nw-resize).png"></td></tr><tr><td style="text-align:left">n-resize</td><td style="text-align:left">此光标指示矩形框的边缘可被向上（北）移动。 <img src="http://upload-images.jianshu.io/upload_images/1808701-0fda13888417d026.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="cursor(n-resize).png"></td></tr><tr><td style="text-align:left">se-resize</td><td style="text-align:left">此光标指示矩形框的边缘可被向下及向右移动（南/东）。<img src="http://upload-images.jianshu.io/upload_images/1808701-0af0018fa284258a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="cursor(se-resize).png"></td></tr><tr><td style="text-align:left">sw-resize</td><td style="text-align:left">此光标指示矩形框的边缘可被向下及向左移动（南/西）。<img src="http://upload-images.jianshu.io/upload_images/1808701-9375173a1ccb6f38.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="cursor(sw-resize).png"></td></tr><tr><td style="text-align:left">s-resize</td><td style="text-align:left">此光标指示矩形框的边缘可被向下移动（南）。 <img src="http://upload-images.jianshu.io/upload_images/1808701-ff9d23221f2e5b9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="cursor(s-resize).png"></td></tr><tr><td style="text-align:left">w-resize</td><td style="text-align:left">此光标指示矩形框的边缘可被向左移动（西）。<img src="http://upload-images.jianshu.io/upload_images/1808701-349251248675553e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="cursor(w-resize).png"></td></tr><tr><td style="text-align:left">text</td><td style="text-align:left">此光标指示文本。<img src="http://upload-images.jianshu.io/upload_images/1808701-afc0e42e53129d1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="cursor(text).png"></td></tr><tr><td style="text-align:left">wait</td><td style="text-align:left">此光标指示程序正忙（通常是一只表或沙漏）。 <img src="http://upload-images.jianshu.io/upload_images/1808701-e649ede76f8f24be.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="cursor(wait).png"></td></tr><tr><td style="text-align:left">help</td><td style="text-align:left">此光标指示可用的帮助（通常是一个问号或一个气球）。 <img src="http://upload-images.jianshu.io/upload_images/1808701-774744be1ba4943b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="cursor(help).png"></td></tr></tbody></table><h2 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;cursor属性&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;p&gt;请把鼠标移动到单词上，可以看到鼠标指针发生变化：&lt;/p&gt;</span><br><span class="line">    &lt;span style=&quot;cursor:auto&quot;&gt;Auto......&lt;/span&gt;&lt;br /&gt;</span><br><span class="line">    &lt;span style=&quot;cursor:crosshair&quot;&gt;Crosshair......&lt;/span&gt;&lt;br /&gt;</span><br><span class="line">    &lt;span style=&quot;cursor:default&quot;&gt;Default......&lt;/span&gt;&lt;br /&gt;</span><br><span class="line">    &lt;span style=&quot;cursor:pointer&quot;&gt;Pointer......&lt;/span&gt;&lt;br /&gt;</span><br><span class="line">    &lt;span style=&quot;cursor:move&quot;&gt;Move......&lt;/span&gt;&lt;br /&gt;</span><br><span class="line">    &lt;span style=&quot;cursor:e-resize&quot;&gt;e-resize......&lt;/span&gt;&lt;br /&gt;</span><br><span class="line">    &lt;span style=&quot;cursor:ne-resize&quot;&gt;ne-resize......&lt;/span&gt;&lt;br /&gt;</span><br><span class="line">    &lt;span style=&quot;cursor:nw-resize&quot;&gt;nw-resize......&lt;/span&gt;&lt;br /&gt;</span><br><span class="line">    &lt;span style=&quot;cursor:n-resize&quot;&gt;n-resize......&lt;/span&gt;&lt;br /&gt;</span><br><span class="line">    &lt;span style=&quot;cursor:se-resize&quot;&gt;se-resize......&lt;/span&gt;&lt;br /&gt;</span><br><span class="line">    &lt;span style=&quot;cursor:sw-resize&quot;&gt;sw-resize......&lt;/span&gt;&lt;br /&gt;</span><br><span class="line">    &lt;span style=&quot;cursor:s-resize&quot;&gt;s-resize......&lt;/span&gt;&lt;br /&gt;</span><br><span class="line">    &lt;span style=&quot;cursor:w-resize&quot;&gt;w-resize......&lt;/span&gt;&lt;br /&gt;</span><br><span class="line">    &lt;span style=&quot;cursor:text&quot;&gt;text......&lt;/span&gt;&lt;br /&gt;</span><br><span class="line">    &lt;span style=&quot;cursor:wait&quot;&gt;wait......&lt;/span&gt;&lt;br /&gt;</span><br><span class="line">    &lt;span style=&quot;cursor:help&quot;&gt;help......&lt;/span&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="参考地址："><a href="#参考地址：" class="headerlink" title="参考地址："></a>参考地址：</h2><p><a href="http://weiqinl.com">我的博客地址weiqinl.com</a><br><a href="http://www.jianshu.com/p/d53ee728d15e" target="_blank" rel="noopener">简书</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在网页布局的时候，在特定的地方，光标形状各有区别。这个时候，就需要用到css的cursor属性。根据自身需要选择设置鼠标指针样式。&lt;/p&gt;
&lt;h2 id=&quot;定义和用法&quot;&gt;&lt;a href=&quot;#定义和用法&quot; class=&quot;headerlink&quot; title=&quot;定义和用法&quot;&gt;&lt;/a&gt;定义和用法&lt;/h2&gt;&lt;p&gt;cursor 属性规定要显示的光标的类型（形状）。&lt;br&gt;该属性定义了鼠标指针放在一个元素边界范围内时所用的光标形状（不过 CSS2.1 没有定义由哪个边界确定这个范围）。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="css" scheme="http://weiqinl.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>Datatables插件1.10.15版本服务器处理模式ajax获取分页数据实例解析</title>
    <link href="http://weiqinl.com/2017/06/30/Datatables%E6%8F%92%E4%BB%B61-10-15%E7%89%88%E6%9C%AC%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A4%84%E7%90%86%E6%A8%A1%E5%BC%8Fajax%E8%8E%B7%E5%8F%96%E5%88%86%E9%A1%B5%E6%95%B0%E6%8D%AE%E5%AE%9E%E4%BE%8B%E8%A7%A3%E6%9E%90/"/>
    <id>http://weiqinl.com/2017/06/30/Datatables插件1-10-15版本服务器处理模式ajax获取分页数据实例解析/</id>
    <published>2017-06-30T06:40:42.000Z</published>
    <updated>2018-04-17T03:13:40.033Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h2><p>前端需要使用表格来展示数据，找了一些插件，最后确定使用dataTables组件来做。</p><p>后端的分页接口已经写好了，不能修改。接口需要传入页码(pageNumber)和页面显示数据条数(pageSize)，显示相应的数据。</p><a id="more"></a><h2 id="二、分析"><a href="#二、分析" class="headerlink" title="二、分析"></a>二、分析</h2><p>先来分析下分页实现。</p><p><strong>一是后端分页： 这种情况，请求的数据，后端返回的数据格式都按着官网来编码，很容易实现，在官网上有示例，不多说明。</strong><br><strong>二是前端分页： 前端分页也是支持的，不过需要一次把所有数据都获取到才可以。</strong></p><p>看到这里，问题来了。由于后端在目前的情况下是更改不了，只能在前端实现。但是，现在 又不满足前端分页的条件 ：</p><p>一次性获取所有数据（现在后端数据接口只能返回相应页码的数据）。</p><p>介于目前的情况，获取的数据只有一页，没有所有的页码。<br>试试能不能 <strong>伪装一下后端分页的情况，就是开启后端分页，在请求之前，将传入的数据进行重组，在获取到数据后，将返回的数据按照后端分页的数据格式组装一遍。</strong></p><p>经过测试，是可以的。</p><h2 id="三、实现"><a href="#三、实现" class="headerlink" title="三、实现"></a>三、实现</h2><p>通过DataTables配置参数<a href="https://datatables.net/reference/option/ajax" target="_blank" rel="noopener">ajax项</a> 实现的<br>目前最新DataTables的版本是1.10.15版本 ，以下是使用此版本。</p><p>关于ajax详细介绍请看官方说明：<a href="http://www.w3school.com.cn/jquery/ajax_ajax.asp" target="_blank" rel="noopener">中文</a> | <a href="https://api.jquery.com/jquery.ajax/" target="_blank" rel="noopener">英文</a></p><p>DataTables参数ajax接收三种类型的参数：</p><ul><li>*string： 设置获取数据的url</li></ul><ul><li>*object：和 jQuery.ajax 定义类似</li></ul><ul><li>*function：自定义获取数据的功能</li></ul><p>直接上代码吧，都有注释。</p><h3 id="前端页面代码："><a href="#前端页面代码：" class="headerlink" title="前端页面代码："></a>前端页面代码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"> </span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;jquery DataTables插件自定义分页ajax实现&lt;/title&gt;</span><br><span class="line">  &lt;link href=&quot;http://cdn.bootcss.com/bootstrap/3.3.6/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot; media=&quot;screen&quot;&gt;</span><br><span class="line">  &lt;link href=&quot;http://cdn.bootcss.com/datatables/1.10.11/css/dataTables.bootstrap.min.css&quot; rel=&quot;stylesheet&quot; media=&quot;screen&quot;&gt;</span><br><span class="line">  &lt;link href=&quot;http://cdn.bootcss.com/datatables/1.10.11/css/jquery.dataTables.min.css&quot; rel=&quot;stylesheet&quot; media=&quot;screen&quot;&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"> </span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div class=&quot;row-fluid&quot;&gt;</span><br><span class="line">    &lt;h3&gt;JQuery DataTables插件自定义分页Ajax实现&lt;/h3&gt;</span><br><span class="line">    &lt;table id=&quot;example&quot; class=&quot;display table-striped table-bordered table-hover table-condensed&quot; cellspacing=&quot;0&quot; width=&quot;100%&quot;&gt;</span><br><span class="line">      &lt;thead&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">          &lt;th&gt;编号&lt;/th&gt;</span><br><span class="line">          &lt;th&gt;姓名&lt;/th&gt;</span><br><span class="line">          &lt;th&gt;性别&lt;/th&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">      &lt;/thead&gt;</span><br><span class="line">    &lt;/table&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;!-- jQuery --&gt;</span><br><span class="line">  &lt;script type=&quot;text/javascript&quot; charset=&quot;utf8&quot; src=&quot;http://code.jquery.com/jquery-1.10.2.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;!-- DataTables --&gt;</span><br><span class="line">  &lt;script type=&quot;text/javascript&quot; charset=&quot;utf8&quot; src=&quot;http://cdn.datatables.net/1.10.15/js/jquery.dataTables.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script src=&quot;http://cdn.bootcss.com/datatables/1.10.11/js/jquery.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script src=&quot;http://cdn.bootcss.com/bootstrap/3.3.6/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script src=&quot;http://cdn.bootcss.com/datatables/1.10.11/js/jquery.dataTables.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script src=&quot;http://cdn.bootcss.com/datatables/1.10.11/js/dataTables.bootstrap.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">  $(function() &#123;</span><br><span class="line">    //提示信息</span><br><span class="line">    var lang = &#123;</span><br><span class="line">      &quot;lengthMenu&quot;: &quot;每页 _MENU_  项&quot;,</span><br><span class="line">      &quot;processing&quot;: &quot;处理中...&quot;,</span><br><span class="line">      &quot;zeroRecords&quot;: &quot;没有匹配结果&quot;,</span><br><span class="line">      &quot;info&quot;: &quot;当前显示第 _START_ 到 _END_ 项, 共 _TOTAL_ 项&quot;,</span><br><span class="line">      &quot;infoEmpty&quot;: &quot;暂无数据&quot;,</span><br><span class="line">      &quot;infoFiltered&quot;: &quot;(由 _MAX_ 项结果过滤)&quot;, //当使用搜索功能后，表格主要信息出追加的字符</span><br><span class="line">      &quot;loadingRecords&quot;: &quot;加载中...&quot;,</span><br><span class="line">      &quot;processing&quot;: &quot;处理中...&quot;,</span><br><span class="line">      &quot;search&quot;: &quot;搜索:&quot;,</span><br><span class="line">      &quot;infoPostFix&quot;: &quot;&quot;, //追加到所有其他主要信息字符串之后</span><br><span class="line">      &quot;url&quot;: &quot;&quot;,</span><br><span class="line">      &quot;emptyTable&quot;: &quot;表中数据为空&quot;,</span><br><span class="line">      &quot;infoThousands&quot;: &quot;,&quot;,</span><br><span class="line">      &quot;paginate&quot;: &#123;</span><br><span class="line">        &quot;first&quot;: &quot;首页&quot;,</span><br><span class="line">        &quot;last&quot;: &quot;末页&quot;,</span><br><span class="line">        &quot;next&quot;: &quot;下页&quot;,</span><br><span class="line">        &quot;previous&quot;: &quot;上页&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    //初始化表格</span><br><span class="line">    var table = $(&quot;#example&quot;).DataTable(&#123;</span><br><span class="line">      language: lang, //提示信息</span><br><span class="line">      stateSave: true, //状态保存，再次加载页面时还原表格状态</span><br><span class="line">      autoWidth: false, //禁用自动调整列宽</span><br><span class="line">      stripeClasses: [&quot;odd&quot;, &quot;even&quot;], //为奇偶行加上样式，兼容不支持CSS伪类的场合</span><br><span class="line">      processing: true, //隐藏加载提示,自行处理</span><br><span class="line">      serverSide: true, //启用服务器端分页</span><br><span class="line">      searching: false, //禁用原生搜索</span><br><span class="line">      orderMulti: false, //启用多列排序</span><br><span class="line">      order: [], //取消默认排序查询,否则复选框一列会出现小箭头</span><br><span class="line">      deferRender: true, //延迟渲染可以提高Datatables的加载速度</span><br><span class="line">      lengthMenu: [</span><br><span class="line">        [10, 25, 50, 100, 300, -1],</span><br><span class="line">        [10, 25, 50, 100, 300, &quot;所有&quot;]</span><br><span class="line">      ], //每页多少项，第一个数组是表示的值，第二个数组用来显示</span><br><span class="line">      renderer: &quot;bootstrap&quot;, //渲染样式：Bootstrap和jquery-ui</span><br><span class="line">      pagingType: &quot;simple_numbers&quot;, //分页样式：simple,simple_numbers,full,full_numbers</span><br><span class="line">      scrollY: 300, //表格的固定高</span><br><span class="line">      scrollCollapse: true, //开启滚动条</span><br><span class="line">      pageLength: 10, //首次加载的数据条数</span><br><span class="line">      columnDefs: [&#123;</span><br><span class="line">       targets: &apos;nosort&apos;, //列的样式名</span><br><span class="line">       orderable: false //包含上样式名‘nosort&apos;的禁止排序</span><br><span class="line">      &#125;],</span><br><span class="line">      //对应列表表头字段</span><br><span class="line">      columns: [&#123;</span><br><span class="line">        &quot;data&quot;: &quot;Id&quot;</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        &quot;data&quot;: &quot;Name&quot;</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        &quot;data&quot;: &quot;Sex&quot;</span><br><span class="line">      &#125;],</span><br><span class="line">      ajax: function(data, callback, settings) &#123;</span><br><span class="line">        //封装请求参数</span><br><span class="line">        var param = &#123;&#125;;</span><br><span class="line">        param.limit = data.length; //页面显示记录条数，在页面显示每页显示多少项的时候</span><br><span class="line">        param.start = data.start; //开始的记录序号</span><br><span class="line">        param.page = (data.start / data.length) + 1; //当前页码</span><br><span class="line">        //console.log(param);</span><br><span class="line">        //ajax请求数据</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">          url: &quot;/hello/list&quot;,</span><br><span class="line">          type: &quot;POST&quot;,</span><br><span class="line">          cache: false, //禁用缓存</span><br><span class="line">          data: param, //传入组装的参数</span><br><span class="line">          dataType: &quot;json&quot;,</span><br><span class="line">          contentType: &apos;application/json;charset=utf-8&apos;,</span><br><span class="line">          beforeSend: function(request) &#123;</span><br><span class="line">            request.setRequestHeader(&quot;token&quot;, localStorage.token);</span><br><span class="line">          &#125;,</span><br><span class="line">          success: function(result) &#123;</span><br><span class="line">            //console.log(result);</span><br><span class="line">            //setTimeout仅为测试延迟效果</span><br><span class="line">            setTimeout(function() &#123;</span><br><span class="line">              //封装返回数据</span><br><span class="line">              var returnData = &#123;&#125;;</span><br><span class="line">              returnData.draw = data.draw; //这里直接自行返回了draw计数器,应该由后台返回</span><br><span class="line">              returnData.recordsTotal = result.total; //返回数据全部记录</span><br><span class="line">              returnData.recordsFiltered = result.total; //后台不实现过滤功能，每次查询均视作全部结果</span><br><span class="line">              returnData.data = result.data; //返回的数据列表</span><br><span class="line">              //console.log(returnData);</span><br><span class="line">              //调用DataTables提供的callback方法，代表数据已封装完成并传回DataTables进行渲染</span><br><span class="line">              //此时的数据需确保正确无误，异常判断应在执行此回调前自行处理完毕</span><br><span class="line">              callback(returnData);</span><br><span class="line">            &#125;, 200);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;,</span><br><span class="line"> </span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">  &#125;);</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"> </span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="JSON数据格式"><a href="#JSON数据格式" class="headerlink" title="JSON数据格式:"></a>JSON数据格式:</h3><p><img src="http://images2015.cnblogs.com/blog/564792/201706/564792-20170630143559118-923358726.png" alt=""></p><h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图:"></a>效果图:</h3><p><img src="http://images2015.cnblogs.com/blog/564792/201706/564792-20170630143543399-2105630772.png" alt=""></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://www.jb51.net/article/84751.htm" target="_blank" rel="noopener">jQuery DataTables插件自定义Ajax分页实例解析</a><br><a href="http://www.cnblogs.com/weiqinl/p/7098746.html" target="_blank" rel="noopener">Datatables插件1.10.15版本服务器处理模式ajax获取分页数据实例解析</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、问题描述&quot;&gt;&lt;a href=&quot;#一、问题描述&quot; class=&quot;headerlink&quot; title=&quot;一、问题描述&quot;&gt;&lt;/a&gt;一、问题描述&lt;/h2&gt;&lt;p&gt;前端需要使用表格来展示数据，找了一些插件，最后确定使用dataTables组件来做。&lt;/p&gt;
&lt;p&gt;后端的分页接口已经写好了，不能修改。接口需要传入页码(pageNumber)和页面显示数据条数(pageSize)，显示相应的数据。&lt;/p&gt;
    
    </summary>
    
    
      <category term="jquery" scheme="http://weiqinl.com/tags/jquery/"/>
    
      <category term="datatables" scheme="http://weiqinl.com/tags/datatables/"/>
    
  </entry>
  
  <entry>
    <title>Vuejs实例-01使用vue-cli脚手架搭建Vue.js项目</title>
    <link href="http://weiqinl.com/2017/06/29/Vuejs%E5%AE%9E%E4%BE%8B-01%E4%BD%BF%E7%94%A8vue-cli%E8%84%9A%E6%89%8B%E6%9E%B6%E6%90%AD%E5%BB%BAVue-js%E9%A1%B9%E7%9B%AE/"/>
    <id>http://weiqinl.com/2017/06/29/Vuejs实例-01使用vue-cli脚手架搭建Vue-js项目/</id>
    <published>2017-06-29T02:54:36.000Z</published>
    <updated>2018-04-17T03:13:40.035Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p><code>vue-cli</code> 一个简单的构建<code>Vue.js</code>项目的命令行界面</p><p>整体过程：</p><pre><code>$ npm install -g vue-cli $ vue init webpack vue-admin $ cd vue-admin $ npm install $ npm run dev </code></pre><p>后面分步说明。<br><a id="more"></a></p><h2 id="2-安装"><a href="#2-安装" class="headerlink" title="2. 安装"></a>2. 安装</h2><p>前提条件，Node.js &gt;=4.x版本，建议使用6.x版本。npm版本 &gt; 3.x<br>全局安装vue-cli</p><pre><code>$ npm install -g vue-cli </code></pre><p><img src="http://images2015.cnblogs.com/blog/564792/201705/564792-20170518211531385-7860564.png" alt="vue-cli-install" title="vue-cli-install"></p><p>…<br><img src="http://images2015.cnblogs.com/blog/564792/201705/564792-20170518211516994-1560191826.png" alt="vue-cli-install" title="vue-cli-install"></p><h2 id="3-使用"><a href="#3-使用" class="headerlink" title="3. 使用"></a>3. 使用</h2><pre><code>$ vue init &lt;template-name&gt; &lt;project-name&gt; </code></pre><p>vue官方提供了多个打包工具版本的模版。我们可以使用<code>vue list</code>命令查看，当前可以使用的模版。</p><pre><code>$ vue list </code></pre><p><img src="http://images2015.cnblogs.com/blog/564792/201705/564792-20170518211446869-690496824.png" alt="vue list" title="vue list"></p><p>我们在这里，使用<code>webpack</code>模版。 功能齐全的<code>webpack</code>&amp; <code>vue-loader</code> 提供热加载、代码检查、单元测试和css分离</p><pre><code>$ vue init webpack vue-element-admin</code></pre><p><img src="http://images2015.cnblogs.com/blog/564792/201705/564792-20170519101621432-221179883.png" alt="vue init" title="vue init"></p><p>之后，在<code>E：\project</code>文件夹下面，会有刚初始化的构建的项目<code>vue-element-admin</code></p><p><img src="http://images2015.cnblogs.com/blog/564792/201705/564792-20170518211346853-1070360488.png" alt="project file" title="project file"></p><h2 id="4-运行结果"><a href="#4-运行结果" class="headerlink" title="4. 运行结果"></a>4. 运行结果</h2><p>项目基础结构已经搭建好了，现在来启动它。<br>进入项目文件:</p><pre><code>$ cd vue-element-admin </code></pre><p>安装依赖：</p><p>中国行情原因，直接安装，有时候会失败。我们一般使用npm的淘宝镜像cnpm。<br>先安装cnpm：</p><pre><code>$ npm install -g cnpm --registry=https://registry.npm.taobao.org</code></pre><p>之后，使用:</p><pre><code>$ cnpm install </code></pre><p>你直接安装也可以的：</p><pre><code>$ npm install </code></pre><p>运行：</p><pre><code>$ npm run dev</code></pre><p><img src="http://images2015.cnblogs.com/blog/564792/201705/564792-20170518211208697-1183076460.png" alt="npm run dev" title="npm run dev"></p><p>启动之后，自动打开默认浏览器 </p><p><img src="http://images2015.cnblogs.com/blog/564792/201705/564792-20170518211307666-440031481.png" alt="admin page" title="主界面"></p><p>之后，就可以进行本地开发，实时预览开发效果。</p><h2 id="5-打包部署"><a href="#5-打包部署" class="headerlink" title="5. 打包部署"></a>5. 打包部署</h2><p>项目开发完成之后，可以使用<code>npm run build</code>进行打包工作</p><pre><code>$ npm run build</code></pre><p>打包完成之后，会生成<code>dist</code>文件夹，项目上线时候，只需要将<code>dist</code>文件夹放到服务器就行了。</p><h2 id="6-项目结构"><a href="#6-项目结构" class="headerlink" title="6. 项目结构"></a>6. 项目结构</h2><p><img src="http://images2015.cnblogs.com/blog/564792/201705/564792-20170518211847322-1043427083.png" alt="项目结构" title="项目结构"></p><pre><code>vue-element-admin:             项目名称 |   .babelrc                   babel的配置文件 |   .editorconfig              编辑器的配置文件 |   .gitignore                 git的忽略文件 |   .postcssrc.js              编译css的工具 |   index.html                 网站主页 |   package.json               项目依赖哪些包的文件 |   README.md                  说明文档 |  +---build                      构建的配置文件夹 |       build.js               项目构建配置入口|       check-versions.js|       dev-client.js|       dev-server.js|       utils.js|       vue-loader.conf.js|       webpack.base.conf.js|       webpack.dev.conf.js|       webpack.prod.conf.js|       webpack.test.conf.js|      +---config                      整体的配置文件夹|       dev.env.js|       index.js                配置文件入口|       prod.env.js|       test.env.js|      +---src                         源文件夹|   |   App.vue                 布局组件|   |   main.js                 入口文件|   |  |   +---assets                  静态文件夹|   |       logo.png|   |      |   +---components              组件文件夹|   |       Hello.vue           单个组件|   |      |   \---router                  路由文件夹|           index.js            路由主页|          +---static                      静态文件夹|       .gitkeep                空文件（Git本身不允许全空目录提交至版本库，一个办法是在目录下创建一个文件，取名为.gitkeep是习惯用法）|      \---test                        测试文件夹</code></pre><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h2><p>  万事开头难，前期项目搭建可能会遇到一些问题，冷静分析慢慢都能解决的。</p><h2 id="8-项目源码"><a href="#8-项目源码" class="headerlink" title="8. 项目源码"></a>8. 项目源码</h2><p><a href="http://www.cnblogs.com/weiqinl/p/6873761.html" target="_blank" rel="noopener">Vuejs实例-Vuejs2.0全家桶结合ELementUI制作后台管理系统</a><br><a href="https://github.com/weiqinl/vue-element-admin" target="_blank" rel="noopener">git项目源码</a></p><p>项目首发于博客园：<a href="http://www.cnblogs.com/weiqinl/p/6875645.html" target="_blank" rel="noopener">Vuejs实例-01使用vue-cli脚手架搭建Vue.js项目</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;1. 前言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;vue-cli&lt;/code&gt; 一个简单的构建&lt;code&gt;Vue.js&lt;/code&gt;项目的命令行界面&lt;/p&gt;
&lt;p&gt;整体过程：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ npm install -g vue-cli 
$ vue init webpack vue-admin 
$ cd vue-admin 
$ npm install 
$ npm run dev 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;后面分步说明。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="vue" scheme="http://weiqinl.com/tags/vue/"/>
    
      <category term="vue-cli" scheme="http://weiqinl.com/tags/vue-cli/"/>
    
  </entry>
  
  <entry>
    <title>使用Github+Hexo框架搭建部署自己的博客</title>
    <link href="http://weiqinl.com/2017/06/21/%E4%BD%BF%E7%94%A8Github-Hexo%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA%E9%83%A8%E7%BD%B2%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    <id>http://weiqinl.com/2017/06/21/使用Github-Hexo框架搭建部署自己的博客/</id>
    <published>2017-06-21T06:05:48.000Z</published>
    <updated>2018-04-17T03:13:40.039Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown &#40;或其他渲染引擎 &#41;解析文章，<br>在几秒内，即可利用靓丽的主题生成静态网页。</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h3><p>安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序：  </p><ul><li>Node.js  </li><li><p>Git<br>如果您的电脑中已经安装上述必备程序，那么恭喜您！接下来只需要使用 npm 即可完成 Hexo 的安装。</p><p>  $ npm install -g hexo-cli</p></li></ul><p>如果您的电脑中尚未安装所需要的程序，请根据以下安装指示完成安装。</p><h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><ul><li>Windows：下载并安装 <a href="https://git-scm.com/download/win" target="_blank" rel="noopener">git</a>.</li></ul><ul><li>Mac：使用 <a href="http://mxcl.github.com/homebrew/" target="_blank" rel="noopener">Homebrew</a>, <a href="http://www.macports.org/" target="_blank" rel="noopener">MacPorts</a> ：<code>brew install git</code>;或下载 <a href="http://sourceforge.net/projects/git-osx-installer/" target="_blank" rel="noopener">安装程序</a> 安装。</li></ul><ul><li>Linux (Ubuntu, Debian)：<code>sudo apt-get install git-core</code></li></ul><ul><li>Linux (Fedora, Red Hat, CentOS)：<code>sudo yum install git-core</code><h3 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h3>安装 Node.js 的最佳方式是使用 nvm。</li></ul><p>cURL:</p><pre><code>$ curl https://raw.github.com/creationix/nvm/master/install.sh | sh</code></pre><p>Wget:</p><pre><code>$ wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh</code></pre><p>安装完成后，重启终端并执行下列命令即可安装 Node.js。</p><pre><code>$ nvm install stable</code></pre><p>或者您也可以下载 <a href="http://nodejs.org/" target="_blank" rel="noopener">安装程序</a> 来安装。</p><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。 </p><pre><code>$ npm install -g hexo-cli</code></pre><h2 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h2><p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p><pre><code>$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install</code></pre><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>Hexo 提供了快速方便的一键部署功能，让您只需一条命令就能将网站部署到服务器上。</p><pre><code>$ hexo deploy</code></pre><p>在开始之前，您必须先在 <code>_config.yml</code> 中修改参数，一个正确的部署配置中至少要有 <code>type</code><br>参数，例如：</p><pre><code>deploy:  type: git</code></pre><p>您可同时使用多个 deployer，Hexo 会依照顺序执行每个 deployer。</p><pre><code>deploy:- type: git  repo:- type: heroku  repo:</code></pre><blockquote><p>缩进<br>YAML依靠缩进来确定元素间的从属关系。因此，请确保每个deployer的缩进长度相同，并且使用空格缩进。</p></blockquote><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><p>如果在使用命令 <code>hexo deploy</code>的时候，报错：</p><pre><code>ERROR Deployer not found: git</code></pre><p>安装 <a href="https://github.com/hexojs/hexo-deployer-git" target="_blank" rel="noopener">hexo-deployer-git</a>。</p><pre><code>$ npm install hexo-deployer-git --save</code></pre><p>修改配置。</p><pre><code>deploy:  type: git  repo: &lt;repository url&gt;  branch: [branch]  message: [message]</code></pre><table><thead><tr><th>参数</th><th style="text-align:right">描述</th></tr></thead><tbody><tr><td>repo</td><td style="text-align:right">库（Repository）地址</td></tr><tr><td>branch</td><td style="text-align:right">分支名称。如果您使用的是 GitHub 或 GitCafe 的话，程序会尝试自动检测。</td></tr><tr><td>message</td><td style="text-align:right">自定义提交信息 (默认为  Site updated: &#123;&#123;  now &#40; ‘YYYY-MM-DD HH:mm:ss’ &#41;  &#125; &#125;)</td></tr></tbody></table><p>我自己的配置为： </p><pre><code># Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:  type: git  repo: git@github.com:weiqinl/weiqinl.github.io  branch: master  message: &apos;提交的消息&apos;</code></pre><p>那么，就可以在<code>weiqinl/weiqinl.github.io</code>库中，找到部署的文件，提交信息为：提交的消息。</p><p>这样，访问地址：<code>https://weiqinl.github.io</code>,hexo博客系统搭建完成。</p><h2 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h2><p><a href="https://hexo.io" target="_blank" rel="noopener">hexo</a><br><a href="http://blog.csdn.net/chwshuang/article/details/52350559" target="_blank" rel="noopener">异常处理</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown &amp;#40;或其他渲染引擎 &amp;#41;解析文章，&lt;br&gt;在几秒内，即可利用靓丽的主题生成静态网页。&lt;/p&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="http://weiqinl.com/tags/hexo/"/>
    
      <category term="github" scheme="http://weiqinl.com/tags/github/"/>
    
      <category term="blog" scheme="http://weiqinl.com/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>hexo指令</title>
    <link href="http://weiqinl.com/2017/06/21/hexo%E6%8C%87%E4%BB%A4/"/>
    <id>http://weiqinl.com/2017/06/21/hexo指令/</id>
    <published>2017-06-21T05:53:40.000Z</published>
    <updated>2018-04-17T03:13:40.037Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hexo指令"><a href="#Hexo指令" class="headerlink" title="Hexo指令"></a>Hexo指令</h1><h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><pre><code>$ hexo init [folder]</code></pre><p>新建一个网站。如果没有设置 <code>folder</code> ，Hexo 默认在目前的文件夹建立网站。</p><a id="more"></a><h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><pre><code>$ hexo new [layout] &lt;title&gt;</code></pre><p>新建一篇文章。如果没有设置 <code>layout</code> 的话，默认使用 <code>_config.yml</code> 中的 <code>default_layout</code> 参数代替。如果标题包含空格的话，请使用引号括起来。</p><h3 id="generate"><a href="#generate" class="headerlink" title="generate."></a>generate.</h3><pre><code>$ hexo generate</code></pre><p>生成静态文件。</p><p>选项    描述<br>-d, –deploy    文件生成后立即部署网站<br>-w, –watch    监视文件变动<br>该命令可以简写为</p><pre><code>$ hexo g</code></pre><h3 id="publish"><a href="#publish" class="headerlink" title="publish"></a>publish</h3><pre><code>$ hexo publish [layout] &lt;filename&gt;</code></pre><p>发表草稿。</p><h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><pre><code>$ hexo server</code></pre><p>启动服务器。默认情况下，访问网址为： <code>http://localhost:4000/</code>。</p><p>选项    描述<br>-p, –port    重设端口<br>-s, –static    只使用静态文件<br>-l, –log    启动日记记录，使用覆盖记录格式  </p><h3 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h3><pre><code>$ hexo deploy</code></pre><p>部署网站。</p><p>参数    描述<br>-g, –generate    部署之前预先生成静态文件<br>该命令可以简写为：</p><pre><code>$ hexo d</code></pre><h3 id="render"><a href="#render" class="headerlink" title="render"></a>render</h3><pre><code>$ hexo render &lt;file1&gt; [file2] ...</code></pre><p>渲染文件。</p><p>参数    描述<br>-o, –output    设置输出路径  </p><h3 id="migrate"><a href="#migrate" class="headerlink" title="migrate"></a>migrate</h3><pre><code>$ hexo migrate &lt;type&gt;</code></pre><p>从其他博客系统 <a href="https://hexo.io/zh-cn/docs/migration.html" target="_blank" rel="noopener">迁移内容</a>。</p><h3 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h3><pre><code>$ hexo clean</code></pre><p>清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)。</p><p>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><pre><code>$ hexo list &lt;type&gt;</code></pre><p>列出网站资料。</p><h3 id="version"><a href="#version" class="headerlink" title="version"></a>version</h3><p>$ hexo version<br>显示 Hexo 版本。</p><h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><h4 id="安全模式"><a href="#安全模式" class="headerlink" title="安全模式"></a>安全模式</h4><pre><code>$ hexo --safe</code></pre><p>在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。</p><h4 id="调试模式"><a href="#调试模式" class="headerlink" title="调试模式"></a>调试模式</h4><pre><code>$ hexo --debug</code></pre><p>在终端中显示调试信息并记录到 <code>debug.log</code>。当您碰到问题时，可以尝试用调试模式重新执行一次，并 提交调试信息到 <a href="https://github.com/hexojs/hexo/issues/new" target="_blank" rel="noopener">GitHub</a>。</p><h4 id="简洁模式"><a href="#简洁模式" class="headerlink" title="简洁模式"></a>简洁模式</h4><pre><code>$ hexo --silent</code></pre><p>隐藏终端信息。</p><h4 id="自定义配置文件的路径"><a href="#自定义配置文件的路径" class="headerlink" title="自定义配置文件的路径"></a>自定义配置文件的路径</h4><pre><code>$ hexo --config custom.yml</code></pre><p>自定义配置文件的路径，执行后将不再使用 <code>_config.yml</code>。</p><h4 id="显示草稿"><a href="#显示草稿" class="headerlink" title="显示草稿"></a>显示草稿</h4><pre><code>$ hexo --draft</code></pre><p>显示 <code>source/_drafts</code> 文件夹中的草稿文章。</p><h4 id="自定义-CWD"><a href="#自定义-CWD" class="headerlink" title="自定义 CWD"></a>自定义 CWD</h4><pre><code>$ hexo --cwd /path/to/cwd</code></pre><p>自定义当前工作目录（Current working directory）的路径。</p><h3 id="引用文章："><a href="#引用文章：" class="headerlink" title="引用文章："></a>引用文章：</h3><p><a href="https://hexo.io/zh-cn/docs/commands.html" target="_blank" rel="noopener">hexo-指令</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Hexo指令&quot;&gt;&lt;a href=&quot;#Hexo指令&quot; class=&quot;headerlink&quot; title=&quot;Hexo指令&quot;&gt;&lt;/a&gt;Hexo指令&lt;/h1&gt;&lt;h3 id=&quot;init&quot;&gt;&lt;a href=&quot;#init&quot; class=&quot;headerlink&quot; title=&quot;init&quot;&gt;&lt;/a&gt;init&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;$ hexo init [folder]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;新建一个网站。如果没有设置 &lt;code&gt;folder&lt;/code&gt; ，Hexo 默认在目前的文件夹建立网站。&lt;/p&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="http://weiqinl.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://weiqinl.com/2017/06/20/hello-world/"/>
    <id>http://weiqinl.com/2017/06/20/hello-world/</id>
    <published>2017-06-20T05:53:40.000Z</published>
    <updated>2018-04-17T03:13:40.036Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&quot;My New Post&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="http://weiqinl.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Windows环境下使用Hexo搭建Github静态博客</title>
    <link href="http://weiqinl.com/2017/06/18/hexo-github-blog/"/>
    <id>http://weiqinl.com/2017/06/18/hexo-github-blog/</id>
    <published>2017-06-18T08:28:31.000Z</published>
    <updated>2018-04-17T03:13:40.036Z</updated>
    
    <content type="html"><![CDATA[<pre><code>注意： 此教程针对的是Windows系统。具体讲解了hexo的配置，其他配置只是略带提下。</code></pre><p>本人一直想搭建个人博客，于是在网上找了资料，自己动手搭建发现并不难。<br>现在，把搭建过程记录下来。</p><p>hexo版本不同，有些配置也会不同。我把我机器配置发出来。</p><p>hexo-v.png</p><h1 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h1><p>本地机器，需要配置一些基础环境，才能更好的搭建hexo博客。</p><a id="more"></a><h2 id="安装Node"><a href="#安装Node" class="headerlink" title="安装Node"></a>安装Node</h2><pre><code>下载安装：http://nodejs.cn/download/</code></pre><h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><pre><code>https://git-scm.com/</code></pre><h2 id="申请GitHub"><a href="#申请GitHub" class="headerlink" title="申请GitHub"></a>申请GitHub</h2><pre><code>需要使用Github，当然得注册一个帐号咯。https://github.com/</code></pre><h2 id="正式安装HEXO"><a href="#正式安装HEXO" class="headerlink" title="正式安装HEXO"></a>正式安装HEXO</h2><p>全局安装hexo, 打开Git 命令，执行如下命令</p><pre><code>$ npm install -g hexo </code></pre><p>这样，安装成功，就可以在全局直接使用hexo命令了。<br>比如，可以使用命令<code>hexo -v</code>查询当前运行的<code>hexo</code>版本.<br>图在一开始，已经发出来了。</p><p>搭建Hexo博客，所需要的配置基本完成。以下是涉及到HEXO的配置了。</p><h1 id="HEXO的配置"><a href="#HEXO的配置" class="headerlink" title="HEXO的配置"></a>HEXO的配置</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>在本地新建一个文件夹，名字和GitHub上的地址名字一样的。比如： <code>weiqinl.github.io</code>。<br>然后，在该文件夹下执行初始化方法：</p><pre><code>$ hexo init</code></pre><p><img src="/2017/06/18/hexo-github-blog/C:/Users\Administrator\Desktop\hexo+github.io\hexo-init.png" alt="hexo-init.png"></p><h2 id="本地启动"><a href="#本地启动" class="headerlink" title="本地启动"></a>本地启动</h2><p>运行下面的命令： </p><pre><code>$ hexo server</code></pre><p>表明<code>Hexo Server</code>已经在本地启动了，在浏览器中输入<code>http://localhost:4000/</code>,这个时候可以看到由<code>Hexo</code>搭建的博客，里面有一篇，系统自带的博文<code>Hello World</code>,介绍如何使用<code>Hexo</code>。<br>你可以按<code>Ctril + C</code> 停止<code>Server</code>。</p><p>可以简化命令，启动服务：</p><pre><code>hexo s -g</code></pre><h2 id="创建一个新文章"><a href="#创建一个新文章" class="headerlink" title="创建一个新文章"></a>创建一个新文章</h2><p>使用命令<code>hexo new &#39;My New Post&#39;</code>创建一个命名为<code>My-New-Post.md</code>的文件，里面默认标题为<code>My New Post</code>的文章。该文章创建在目录 <code>/source/_posts/</code>下。此时，就可以打开该文件，使用Markdown风格的编辑器来编辑。</p><pre><code>$ hexo new &apos;My New Post&apos;INFO  Created: E:\project\weiqinl.github.io\source\_posts\My-New-Post‘.md</code></pre><h2 id="生成静态页面"><a href="#生成静态页面" class="headerlink" title="生成静态页面"></a>生成静态页面</h2><p>执行以下命令，将markdown文件生成静态网页。</p><pre><code>$ hexo generate </code></pre><p>该命令执行完成后，会在根目录下生成文件夹<code>public</code>,里面是该站点的相关css和js。</p><h2 id="git部署"><a href="#git部署" class="headerlink" title="git部署"></a>git部署</h2><p>修改_config.yml文件，如下： </p><pre><code># Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:  type: git  repository: git@github.com:weiqinl/weiqinl.github.io  branch: master</code></pre><p>执行命令：</p><pre><code>$ hexo deploy</code></pre><p>  这里，如果遇到问题：</p><pre><code>$ hexo deployERROR Deployer not found: git</code></pre><p>那么执行命令：</p><pre><code>$ npm install hexo-deployer-git --save</code></pre><p>执行成功之后，再次运行命令<code>hexo deploy</code></p><p>此时，博客就算是发布成功了。可以通过地址<code>weiqinl.github.io</code>查看。  </p><p>每次部署的步骤，可以按照以下三步来进行。</p><pre><code>hexo cleanhexo generatehexo deploy</code></pre><p>##一些常用命令<br>    hexo new ‘My New Post’ # 创建一个新文章，名字为’My New Post’<br>    hexo clean #清除Hexo的缓存和生成的静态页面<br>    hexo generate #生成静态页面 hexo g<br>    hexo deploy #部署 hexo d<br>    hexo server #启动本地hexo服务,进行文章预览调试 hexo s<br>    hexo -v # hexo版本信息 hexo -v<br>    hexo init #初始化文件夹 </p><p>##参考案例： </p><p>Hexo搭建Github静态博客： <a href="http://www.cnblogs.com/zhcncn/p/4097881.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhcncn/p/4097881.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;注意： 此教程针对的是Windows系统。具体讲解了hexo的配置，其他配置只是略带提下。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;本人一直想搭建个人博客，于是在网上找了资料，自己动手搭建发现并不难。&lt;br&gt;现在，把搭建过程记录下来。&lt;/p&gt;
&lt;p&gt;hexo版本不同，有些配置也会不同。我把我机器配置发出来。&lt;/p&gt;
&lt;p&gt;hexo-v.png&lt;/p&gt;
&lt;h1 id=&quot;配置环境&quot;&gt;&lt;a href=&quot;#配置环境&quot; class=&quot;headerlink&quot; title=&quot;配置环境&quot;&gt;&lt;/a&gt;配置环境&lt;/h1&gt;&lt;p&gt;本地机器，需要配置一些基础环境，才能更好的搭建hexo博客。&lt;/p&gt;
    
    </summary>
    
    
      <category term="windows" scheme="http://weiqinl.com/tags/windows/"/>
    
      <category term="hexo" scheme="http://weiqinl.com/tags/hexo/"/>
    
      <category term="github" scheme="http://weiqinl.com/tags/github/"/>
    
      <category term="blog" scheme="http://weiqinl.com/tags/blog/"/>
    
  </entry>
  
</feed>
